<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <link rel="stylesheet" href="../../dist/zenburn.css" />

    <title>reveal.js</title>

    <link rel="stylesheet" href="../../dist/reset.css" />
    <link rel="stylesheet" href="../../dist/reveal.css" />
    <link rel="stylesheet" href="../../dist/theme/black.css" />

    <!-- Theme used for syntax highlighted code -->
    <link rel="stylesheet" href="../../plugin/highlight/monokai.css" />
  </head>
  
  <body>
    <div class="reveal">
      <div class="slides">
        <section>
          <h2>Generics</h2>
          <p style="font-style:italic">"Components that are capable of working on the data of today as well as the
              data of tomorrow will give you the most flexible capabilities for building up large software
              systems"</p>
      </section>
      <section>
          <h3>Let's implement a map</h3>
          <pre><code class="language-typescript">
interface Map {
  get(key: string): Object;
  set(key: string, value: Object): void;
}
          </code></pre>
          <p class="fragment">What's the problem here?</p>
      </section>
      <section>
          <h2>Generics! üôå</h2>
          <pre><code class="language-typescript">
interface Map&lt;T> {
  get(key: string): T;
  set(key: string, value: T): void;
}
      </code></pre>
      </section>
      <section>
          <h2>top level vs. function generics</h2>
          <pre><code class="language-typescript">
interface Map {
  get&lt;T>(key: string): T;
  set&lt;T>(key: string, value: T): void;
}
          </code></pre>
      </section>
      <section>
          <h2>Another example</h2>
          <pre><code class="language-typescript">class Engine&lt;T>{
  constructor(private runnable: T){}
  run(){
    this.runnable.run();
  }
}</code></pre>
          <div class="fragment">
              <p>Would it work?</p>
              <p>What is the type of T?</p>
          </div>
      </section>
      <section>
          <h2>Generic constrains üí™</h2>
          <pre><code class="language-typescript" data-trim="" data-noescape="">
          interface Runnable {
              run(): void;
          }
          class Engine&lt;T extends Runnable>{
              constructor(private runnable: T) { }
              run() {
                  this.runnable.run();
              }
          }
          </code></pre>
      </section>
      <section>
          <pre><code class="language-typescript">function fetchProperty&lt;T>(object: T, propertyName: string){
  return object[propertyName];
}</code></pre>
          <div>
              <p>Would it work?</p>
              <p>What is the type of T?</p>
          </div>
          <div class="fragment">
              <pre><code class="language-typescript">function fetchProperty&lt;T, PropName extends keyof T>(object: T, propertyName: PropName){
  return object[propertyName];
}</code></pre>
              <p>And now? üí™</p>
          </div>
      </section>
      <section>
          <pre><code class="language-typescript">function animalFactory&lt;T>(Animal: T,){
  return new Animal();
}</code></pre>
          <p>Ok, this deffinitely must work, right?</p>
          <img class="fragment" height="100" style="position: absolute; top:-130px;right:-100px"
              src="../../assets/error1.png" />
          <div class="fragment">
              <pre><code class="language-typescript">function animalFactory&lt;T>(Animal: { new(): T }) {
  return new Animal();
}</code></pre>
              <p>Now it works with class types üí™</p>
          </div>
      </section>
      <section>
          <h2>Lets combine everything</h2>
          <pre><code class="language-typescript" data-noescape="" data-trim="">
          class Animal { }
          interface Runnable {
              run(): void;
          }
          class Cat extends Animal implements Runnable {
              run() { }
          }
          class Dog extends Animal implements Runnable {
              run() { }
          }
          function animalFactory&lt;T extends Animal>(Animal: { new(): T }) {
              return new Animal();
          }
          function startRunning&lt;T extends Runnable>(runnable: T) {
              runnable.run();
          }</code></pre>
      </section>
      <section>
          <h2>Mixins</h2>
          <p>let's add a map</p>
          <pre><code>
const map = new Map&lt;string, string>();
map.set('1', 'something');
map.set('2', 'another thing');
          </code></pre>
          <p class="fragment">
              now let's add a concatinate function to it.
          </p>
      </section>
      <section>
          <h2>take 1</h2>
          <pre><code class="language-typescript">
class ConcatinateableMap extends Map{
  concatinate(): string {
    let total = '';
    for (const value of this.values()) {
        total += value + '\n';
    }

    return total;
  }
}
          </code></pre>
      </section>
      <section>
          <div style="text-align: left;">
              <p style="text-decoration: underline;">pros</p>
              <ul>
                  <li>simple</li>
              </ul>
              <p style="text-decoration: underline;">cons</p>
              <ul>
                  <li>Need to create class for every type of class that has values</li>
              </ul>
          </div>
      </section>
      <section>
          <h2>take 2</h2>
          <pre><code class="language-typescript">class ContainableMap {
  private map = new Map&lt;string, string>();
  concatinate(): string {
    let total = '';
    for (const value of this.map.values()) {
        total += value + '\n';
    }

    return total;
  }
}</code></pre>
      </section>
      <section>
          <div style="text-align: left;">
              <p style="text-decoration: underline;">pros</p>
              <ul>
                  <li>simple</li>
              </ul>
              <p style="text-decoration: underline;">cons</p>
              <ul>
                  <li>Need to create class for every type of class that has values</li>
                  <li>Not really extends the class but hides the map inside</li>
              </ul>
          </div>
      </section>
      <section>
          <h2>take 3</h2>
          <pre><code class="language-typescript">type Constructor<T> = new (...args: any[]) => T;
type ValuesConstructor&lt;ValuesType> = Constructor&lt;{ values: () => IterableIterator&lt;ValuesType> }>;
function getConcatinatableMap&lt;T extends ValuesConstructor&lt;string>>(Base: T) {
return class extends Base {
  concatinate(): string {
      let total = '';
      for (const value of this.values()) {
          total += value + '\n';
      }
      return total;
  }
}
}
const ConcatinatableMap = getConcatinatableMap(Map);
const map = new ConcatinatableMap();
map.concatinate() ü§Ø</code></pre>
      </section>
      <section>
          <h2>DIY(mixins)</h2>
          <ul>
              <li>create animal class (choose your favorite animal</li>
              <li>create 2 behaviour mixings, one for animals that can fly</li>
              <li>the other for animals that can swim</li>
              <li>give your animal both behaviors</li>
          </ul>
      </section>
      <section>
          <h2>Decorators</h2>
          <p>Generally follows decoration pattern</p>
      </section>
      <section>
          <h2>Decoration Pattern</h2>
          <img height="400" src="../../assets/decoration-pattern.png" />
      </section>
      <section>
          <h2>Decoration Kurzgesagt</h2>
          <h4 style="font-style: italic;">(In a Nutshell)</h4>
          <ul>
              <li>Give execution of a component to another entity</li>
              <li>Another entity executes additional code together with original one</li>
          </ul>
      </section>
      <section>
          <h2>Activating Decorators</h2>
          <pre><code class="language-bash">
"experimentalDecorators": true,
"emitDecoratorMetadata": true, 
          </code></pre>
          <small>In tsconfig.json</small>
      </section>
      <section>
          <h2>Decorators in Typescript (Angular)</h2>
          <pre><code class="language-typescript">
@Injectable()
class UsefulService {
}

@Injectable()
class NeedsService {
  constructor(public service: UsefulService) {}
}
          </code></pre>
      </section>
      <section>
          <h2>Decorators in Typescript (Inversify)</h2>
          <pre><code  class="language-typescript">
@injectable()
class Ninja implements Warrior {
@inject(TYPES.Weapon) private _katana: Weapon;
@inject(TYPES.ThrowableWeapon) private _shuriken: ThrowableWeapon;
public fight() { return this._katana.hit(); }
public sneak() { return this._shuriken.throw(); }
}
          </code></pre>
      </section>
      <section>
          <h2>Decorators Types</h2>
          <h4>(In Typescript)</h4>
          <ul>
              <li>Class</li>
              <li>Property</li>
              <li>Accessor</li>
              <li>Method</li>
              <li>Patameter</li>
          </ul>
      </section>
      <section>
          <h3>Decorator vs. Decorator Factory</h3>
          <ul style="list-style: none;">
              <li>Decorator - creates direct decorator</li>
              <li>Factory - allows customization of decorators</li>
          </ul>
      </section>
      <section>
          <h2>Decorator Factory Example</h2>
          <pre><code class="language-typescript">
function color(value: string) {
// this is the decorator factory, it sets up
// the returned decorator function
  return function (target) {
    // this is the decorator
    // do something with 'target' and 'value'...
  };
}                    
          </code></pre>
          <small>from: <a
                  href="https://www.typescriptlang.org/docs/handbook/decorators.html">https://www.typescriptlang.org/docs/handbook/decorators.htm</a></small>
      </section>
      <section>
          <h2>Class Decorators (implementation)</h2>
          <pre><code class="language-typescript">
function ConstructorPerformance(Constructor: { new(...args: any[]): any }) {
  return class extends Constructor {
    constructor(...args: any[]) {
        const start = new Date();
        super(args);
        const end = new Date();
        console.log(`took ${end.getTime() - start.getTime()}ms to finish construction`);
    }
  }
}
          </code></pre>
      </section>
      <section>
          <h2>Class Decorators (Usage)</h2>
          <pre><code class="language-typescript">
@ConstructorPerformance
class Test {
  constructor(){
    let result = 1
    for (let index = 1; index < 10000; index++) {
        result *= index;
    }
  }
}
const test = new Test();
          </code></pre>
          <pre><code class="language-bash">
took 12ms to finish construction
</code></pre>
      </section>
      <section>
          <h2>Method Decorator (implementation)</h2>
          <pre><code class="language-typescript">
function ExceptionWrapper(target: any, propertyKey: string, descriptor: TypedPropertyDescriptor<(...args: any[]) => void>) {
  const originalFunction  = target[propertyKey];
  descriptor.value = (...args: any[]) => {
    try{
        originalFunction.apply(target, ...args);
    } catch(error){
        const typedError = error as Error
        console.log(`caught exception in wrapper, ${typedError.message}`);
    }
  }
}
          </code></pre>
      </section>
      <section>
          <h2>Method Decorator (usage)</h2>
          <pre><code class="language-typescript">
export class Test {
  @ExceptionWrapper
  throwException(someValue: string) {
    throw new Error(someValue);
  }
}


const t = new Test();
console.log(t.throwException('some string'));
          </code></pre>
      </section>
      <section>
          <h2>Reflection and Metadata</h2>
          <h4>Let's look at the code</h4>
          <pre><code>
__decorate([
ExceptionWrapper,
__metadata("design:type", Function),
__metadata("design:paramtypes", [String]),
__metadata("design:returntype", void 0)
], Test.prototype, "throwException", null);
exports.Test = Test;
const t = new Test();
console.log(t.throwException('some string'));                    
          </code></pre>
          <small>Insufficient reflection</small>
      </section>
      <section>
          <h2>reflect-metadta to the rescue</h2>
          <ul>
              <li><a
                      href="https://www.npmjs.com/package/reflect-metadata">https://www.npmjs.com/package/reflect-metadata</a>
              </li>
              <li>~4M weekly downloads</li>
              <li><a href="https://rbuckton.github.io/reflect-metadata/">Detailed Proposal</a></li>
          </ul>
      </section>
      <section>
          <h2>Reflection with reflect-metadata</h2>
          <pre><code>
import 'reflect-metadata';
function ConstructorPerformance(Constructor: { new(...args: any[]): any }) {
  const start = new Date();
  const metadataKeys = Reflect.getOwnMetadataKeys(Constructor); // ['design:paramtypes']
  const metadataPatamtypes = Reflect.getMetadata('design:paramtypes', Constructor);
  console.log(metadataPatamtypes.map((param:any) => param.name)); // [ 'String', 'Boolean' ]
  return class extends Constructor {
    constructor(...args: any[]) {
        const start = new Date();
        super(args);
        const end = new Date();
        console.log(`took ${end.getTime() - start.getTime()}ms to finish construction`);
    }
  }
}
          </code></pre>
      </section>
      <section>
          <h2>Wait... What about javascript?</h2>
          <p>Javascript decorators are at <a href="https://github.com/tc39/proposal-decorators">stage2</a> </p>
          <p>Which means: The committee expects the feature to be developed and eventually included in the
              standard</p>
      </section>
      <section>
          <h2>DIY (decorators)</h2>
          <ul>
              <li>Create an autologger decorator (method decorator)</li>
              <li>Should log once in a beginning of a function</li>
              <li>Should log all params with their values</li>
          </ul>
      </section>
      <section>
          <h1>done!</h1>
      </section>
        <section data-background="#007acc">
          <h4>
            Things you should have known in TypeScript but you
            probably don't
          </h4>
        </section>
        <section data-background="#007acc">
          <section>
            <h4>string, number or boolean literal as a type</h4> 
            <aside class="notes">
              A literal is a more concrete sub-type of a collective type. What
              this means is that "Hello World" is a string, but a string is not
              "Hello World" inside the type system.
            </aside>
          </section>
          <section id="fragments">
            <p>
              1. strings
            </p>
            <p class="fragment">

              2. numbers
            </p>
            <p class="fragment">
              3. booleans
            </p>
            <aside class="notes">
            There are three sets of literal types available in TypeScript today:
            strings, numbers, and booleans; by using literal types you can allow
            an exact value which a string, number, or boolean
          </aside>
          </section>
          <section id="fragments">
           <p> for instance if a create a variable </p> 
            <pre class="fragment"><code data-trim data-noescape>
				const number = 23 
			</code></pre>
          <aside class="notes">
              TypeScript will infer the type of this const as 23 (and not a number
              in general) since it is a const and it will never change!
            </aside>
          </section>
          <section data-background="#007acc">
            <h2 data-id="code-title">For example:</h2>
            <pre><code class="typescript-language" data-trim data-noescape>
				type Asaf = 'Asaf';
				
				// no error
				const name: Asaf = 'Asaf'
				const age: 32 = 32
		
				// error
				
				// Type '"Niv"' is not assignable to type '"Asaf"'
				const name: Asaf = 'Niv'
				
				// Type '40' is not assignable to type '32'
				const age: 32 = 40
			</code></pre>
          </section>
          <section>
            <h2 data-id="code-title">For example - consider the next function:</h2>
            <pre><code data-trim data-noescape>
			const combine = (
				input1: number , 
				input2: number, 
				resultConversion: string
			) => {
				if(resultConversion === "as-number"){
					return input1 + input2;
				}
				else{
					const res = input1 + input2;
					return res.toString();
				}
			}
			</code></pre>
          </section>
          <section>
            <pre><code data-trim data-noescape data-line-numbers="4">
			const combine = (
				input1: number , 
				input2: number, 
				resultConversion: 'as-string' | 'as-number'
			) => {
				if(resultConversion === as-number){
					return input1 + input2;
				}
				else{
					const res = input1 + input2;
					return res.toString();
				}
			}
			</code></pre>
          </section>
          <section>
            <h2 data-id="code-title">For example:</h2>
            <pre><code data-trim data-noescape data-line-numbers="1,5, 15, 17">
			type ResultConversion =  'as-string' | 'as-number'
			const combine = (
				input1: number , 
				input2: number, 
				resultConversion: ResultConversion
			) => {
				if(resultConversion === "as-number"){
					return input1 + input2;
				}
				else{
					const res = input1 + input2;
					return res.toString();
				}
			}
			</code></pre>
          </section>
          <section id="fragments">
            <aside class="notes"> 
              in this way we can both prevent other people from sending
              unrealted strings to this function and prevent typos like
              "as-strnig".
            </aside>

            <p class="fragment">any other string will not be alowed.</p>

            <p class="fragment">most of the time it will be used in a Union type</p>

            <pre class="fragment"><code data-trim data-noescape>
				combine(1, 2, 'as-string') // 3 
				combine(1, 2, 'as-strnig')
			 // Argument of type '"as-strnig"' is not assignable to parameter oftype 'ResultConversion'.(2345)
			</code></pre>
          </section>
          <section>
            <h1>Quiz</h1>
          </section>
          <section>
            <p> What can not be a literal type?</p>
            <p>1. String </p>
            <p>2. Number </p>
            <p>3. Array </p>
            <p>4. Boolean </p>
          </section>
          <section>
            <p> What will be the type of this expression? </p>
            <pre><code data-trim data-noescape>
              const name = 'name'
            </code></pre>
          </section>
        </section>
        <section data-background="#007acc">
          <section>
            <h4>Rest params in function parameters and Tuples</h4>
          </section>
          <section>
            <aside class="notes"> 
              A rest parameter allows you a function to accept zero or more
              arguments of the specified type. In TypeScript, rest parameters
              follow these rules:
            </aside>

            <p >1. A function has only one rest parameter.</p>
            <p class="fragment">2. The rest parameter appears last in the parameter list.</p>
            <p class="fragment">3. The type of the rest parameter is an array type.</p>

            <pre class="fragment"><code data-trim data-noescape>
				function fn(...rest: type[]) {
					//...
				 }
			</code></pre>
          </section>
          <section>
            <pre><code data-trim data-noescape>
				function getTotal(...numbers: number[]): number {
					let total = 0;
					numbers.forEach((num) => total += num);
					return total;
				}
			</code></pre>
          </section>
          <section>
            <pre><code data-trim data-noescape>
            console.log(getTotal()); // 0
            console.log(getTotal(10, 20)); // 30
            console.log(getTotal(10, 20, 30)); // 60
          </code></pre>
          </section>

          <section id="fragments">
            <aside class="notes"> 
              Rest params can be used an Tuples as well
              
              Tuple types allow you to express an array with a fixed number of
              elements whose types are known, but need not be the same.
            </aside>
              <pre><code data-trim data-noescape>
                // Declare a tuple type
                let x: [string, number];
                // Initialize it
                x = ["hello", 10]; // OK
                // Initialize it incorrectly
                x = [10, "hello"]; // Error
              </code></pre>
            </section>
          <section>
            <aside class="notes"> 
              In TypeScript 4.2, rest elements specifically been expanded in how
              they can be used. In prior versions, TypeScript only allowed
              ...rest elements at the very last position of a tuple type.

              However, now rest elements can occur anywhere within a tuple -
              with only a few restrictions.
              </aside>
            <pre><code data-trim data-noescape>			
				let foo: [...string[], number];
		
				foo = [123];
				foo = ["hello", 123];
				foo = ["hello!", "hello!", "hello!", 123];
		
				let bar: [boolean, ...string[], boolean];
		
				bar = [true, false];
				bar = [true, "some text", false];
				bar = [true, "some", "separated", "text", false];
				</code></pre>
        </section>
        <section id="fragments">
            <aside class="notes"> 
              The only restriction is that a rest element can be placed anywhere
              in a tuple, so long as it‚Äôs not followed by another optional
              element or rest element.

              In other words, only one rest element per tuple, and no optional
              elements after rest elements.
              </aside>
            <pre><code data-trim data-noescape>		
				interface Clown {
					/*...*/
				  }
				  interface Joker {
					/*...*/
				  }
				   
				  let StealersWheel: [...Clown[], "me", ...Joker[]];
				  // A rest element cannot follow another rest element.
				   
				  let StringsAndMaybeBoolean: [...string[], boolean?];
				  // An optional element cannot follow a rest element.	
			</code></pre>
          </section>
          <section id="fragments">
            <aside class="notes"> 
              These non-trailing rest elements can be used to model functions
              that take any number of leading arguments, followed by a few fixed
              ones.
            </aside>
            <pre class="fragments"><code data-trim data-noescape>		
				const doStuff = (
					...args: [...names: string[], 
					shouldCapitalize: boolean]
				) void => {
					// do stuff...
				}
 
				doStuff(false)
				doStuff("fee", "fi", "fo", "fum",true);
			</code></pre>
          </section>
          <section>
            <h1>Quiz</h1>
          </section>
          <section>
            <p> which of these is not correct? </p>
            <pre class="fragment"><code data-trim data-noescape>let bar:[...number[], boolean]	</code></pre>
            <pre class="fragment"><code data-trim data-noescape>	function foo(bool: boolean, num: number, ...rest: string[])</code></pre>
            <pre class="fragment"><code data-trim data-noescape> let x:[...number, string?]	</code></pre></p>
            <pre class="fragment"><code data-trim data-noescape>	
              const func =
               (...args:[...phoneNumbers :number[], shouldBeCalled:boolean])
              :void => {}</code></pre>
          </section>
        </section>
        <section data-background="#007acc">
          <section>
            <h4>Union types</h4>
            <aside class="notes"> 
              A union type describes a value that can be one of several types.
              We use the vertical bar (|) to separate each type, so number |
              string | boolean is the type of a value that can be a number, a
              string, or a boolean.
           </aside>
          </section>
          <section>
            <pre><code data-trim data-noescape>		
					interface Bird {
						fly(): void;
						layEggs(): void;
					  }
					   
					  interface Fish {
						swim(): void;
						layEggs(): void;
					  }
					   
					  declare function getSmallPet(): Fish | Bird;
					   
					  let pet = getSmallPet();
					  pet.layEggs();
					   
					  // Only available in one of the two possible types
					  pet.swim();
					  /* Property 'swim' does not exist on type 'Bird | Fish'.
						roperty 'swim' does not exist on type 'Bird'.*/
				</code></pre>
        <aside class="notes"> 
            Union types can be a bit tricky here, but it just takes a bit of
            intuition to get used to. If a value has the type A | B, we only
            know for certain that it has members that both A and B have. In
            this example, Bird has a member named fly. We can‚Äôt be sure
            whether a variable typed as Bird | Fish has a fly method. If the
            variable is really a Fish at runtime, then calling pet.fly() will
          fail.
        </aside>
          </section>
          <section>
            <h4>Discriminating Unions</h4>
            <aside class="notes"> 
              A common technique for working with unions is to have a single
              field which uses literal types which you can use to let TypeScript
              narrow down the possible current type. For example, we‚Äôre going to
              create a union of three types which have a single shared field.
            </aside>
          </section>
          <section data-auto-animate>
            <pre data-id="code-animation" ><code class="hljs" data-trim data-line-numbers="|1-15|16,17|18-21">	<script type="text/template">
				type NetworkLoadingState = {
					state: "loading";
				  };
				  type NetworkFailedState = {
					state: "failed";
					code: number;
				  };
				  type NetworkSuccessState = {
					state: "success";
					response: {
					  title: string;
					  duration: number;
					  summary: string;
					};
				  };
				  // Create a type which represents only one of the above types
				  // but you aren't sure which it is yet.
				  type NetworkState =
					| NetworkLoadingState
					| NetworkFailedState
					| NetworkSuccessState;
				</script></code></pre>
          </section>
          <section id="fragments">
            <aside class="notes"> 
              In this case, you can use a switch statement to narrow down which
              type is represented at runtime:

              By switching on state, TypeScript can narrow the union down in code flow analysis
            </aside>
            <pre><code class="hljs" data-trim data-line-numbers="|1-4|6|8-10|11-20">		
				type NetworkState =
					| NetworkLoadingState
					| NetworkFailedState
					| NetworkSuccessState;

					function logger(state: NetworkState): string {

            // Trying to access a property which isn't shared
            // across all types will raise an error
            state.code;

					switch (state.state) {
					case "loading":
						return "Downloading...";
					case "failed":
						return `Error ${state.code} downloading`;
					case "success":
						return `Downloaded ${state.response.title} - ${state.response.summary}`;
						}
					}
				</code></pre>
          </section>
          <section id="fragments">
            <h1>Quiz</h1>
            <p>consider the next types</p>
            <pre class="fragment" data-id="code-animation" ><code class="hljs">	<script type="text/template">
              type TypeOne = {
                name: 'one';
                age: number;
              }
            </script></code></pre>
            <pre class="fragment" data-id="code-animation" ><code class="hljs">	<script type="text/template">
              type TypeTwo = {
                name: 'two';
                address: string;
              }
            </script></code></pre>
            </section>
            <section>
            <pre class="fragment" data-id="code-animation" ><code class="hljs">	<script type="text/template">
              type OneAndTwo = TypeOne | TypeTwo
            </script></code></pre>
            <pre class="fragment" data-id="code-animation" ><code class="hljs">	<script type="text/template">
              function foo(bar: OneAndTwo): void {
                // valid?
                if(bar.name === 'one'){
                  console.log(bar.age)
                }

                // valid?
                if(bar.name === 'two'){
                  console.log(bar.age)
                }

                // valid?
                if(bar.name === 'two'){
                  console.log(bar.address)
                }
              }
            </script></code></pre>
            </section>
          </section>
        </section>
        <section data-background="#007acc">
          <section>
            <h4>Type vs Interface</h4>
          </section>
          <section>
            <p>Interface</p>
            <aside class="notes"> 
              One of TypeScript‚Äôs core principles is that type checking focuses
              on the shape that values have. This is sometimes called ‚Äúduck
              typing‚Äù or ‚Äústructural subtyping‚Äù. In TypeScript, interfaces fill
              the role of naming these types, and are a powerful way of defining
              contracts within your code as well as contracts with code outside
              of your project.
            </aside>
          </section>
          <section>
            <p>1. Interfaces can be extended and implemented</p>
            <pre><code  class="hljs" data-trim data-line-numbers="|1-5|7-11|13|15-17|19-24">		
              interface Person {
                name: string,
                age: number
                sayHello:() => void
              }
              
              class SomePerson implements Person {
                name ='Asaf'
                age = 32
                sayHello () {console.log('Hello')}
              }

              const p = new SomePerson();
              
              interface Developer extends Person{
                typescriptMaster: boolean
              }
              
              const me: Developer = {
                  name: 'Asaf',
                  age: 32,
                  typescriptMaster: true,
                  sayHello: () => console.log('Hello')
              }
				</code></pre>
          </section>
          <section>
            <p>2. Declaration merging</p>
            <aside class="notes"> 
              ‚Äúdeclaration merging‚Äù means that the compiler merges two separate
              declarations declared with the same name into a single definition.
              This merged definition has the features of both of the original
              declarations. Any number of declarations can be merged; it‚Äôs not
              limited to just two declarations.
            </aside>
          </section>
          <section>
            <pre><code data-trim data-noescape>		
					interface Box {
						height: number;
						width: number;
					  }

					  interface Box {
						scale: number;
					  }

					  let box: Box = { height: 5, width: 6, scale: 10 };
				</code></pre>
          </section>
          <section>
            <p>Type alias</p>
            <aside class="notes"> 
              it‚Äôs common to want to use the same type more than once and refer
              to it by a single name. A type alias is exactly that - a name for
              any type. The syntax for a type alias is:
            </aside>
          </section>
          <section>
            <p>1. types can not be extended - types intersection</p>
            <pre><code data-trim data-noescape>		
					type Person = {
						name: string,
						age: number
					} &  { typescriptMaster: boolean }
					
					const me: Person = {
						name: 'Asaf',
						age: 32,
						typescriptMaster: true
					}
				</code></pre>
          </section>
          <section>
            <p>2. Union types</p>
            <p></p>
            <pre><code data-trim data-noescape>		
						type Person = {
							name: string,
							age: number
						} 
						
						type TypescriptMaster = { typescriptMaster: boolean }

						type Asaf = Person | TypescriptMaster 
						
						const me: Asaf = {
							name: 'Asaf',
							age: 32,
						}

						// or 
						const me: Asaf = {
							typescriptMaster: true;
						}

						// or
						const me: Asaf = {
							name: 'Asaf',
							age: 32,
							typescriptMaster: true;
						}
					</code></pre>
          </section>
        </section>
        <section data-background="#007acc">
          <section >
           <h4> type never </h4> 
           <aside class="notes">
            The never type represents the type of values that never occur. For
            instance, never is the return type for a function expression or an
            arrow function expression that always throws an exception or one
            that never returns. Variables also acquire the type never when
            narrowed by any type guards that can never be true. The never type
            is a subtype of, and assignable to, every type; however, no type
            is a subtype of, or assignable to, never (except never itself).
            Even any isn‚Äôt assignable to never.
           </aside>
          </section>
          <section>
            <pre><code data-trim data-noescape>		
				// Function returning never must not have a reachable end point
				function error(message: string): never {
				  throw new Error(message);
				}
				 
				// Inferred return type is never
				function fail() {
				  return error("Something failed");
				}
				 
				// Function returning never must not have a reachable end point
				function infiniteLoop(): never {
				  while (true) {}
				}
			</code></pre>
          </section>
          <section>
            <h4> type unknown</h4>
            <aside class="notes"> 
              the unknown type is simmilar to the any type, however you can't
              assign a value of type unknown to another value with different
              type without type check (typeof) first.
            </aside>
          </section>
          <section>
            <pre><code data-trim data-noescape>		
			let unknownUserInput: unknown;
			let anyUserInput: any;
			let userName : string;

			// valid 
			unknownUserInput = 5
			anyUserInput = 5 


			// valid 
			unknownUserInput = 'Asaf'
			anyUserInput = 'Asaf'

			// valid 
			userName = anyUserInput;

			// invalid 
			userName = unknownUserInput;

			//fix - valid
			if(typeof unknownUserInput === string){
				userName = unknownUserInput;
			}

		</code></pre>
          </section>
        </section>
        </section>
      </div>
    </div>

    <script src="../../dist/reveal.js"></script>
    <script src="../../plugin/notes/notes.js"></script>
    <script src="../../plugin/markdown/markdown.js"></script>
    <script src="../../plugin/highlight/highlight.js"></script>
    <script>
      // More info about initialization & config:
      // - https://revealjs.com/initialization/
      // - https://revealjs.com/config/
      Reveal.initialize({
        hash: true,

        // Learn about plugins: https://revealjs.com/plugins/
        plugins: [RevealMarkdown, RevealHighlight, RevealNotes],
      });
    </script>
  </body>
</html>
