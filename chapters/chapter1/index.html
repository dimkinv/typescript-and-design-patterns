<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <link rel="stylesheet" href="../../dist/zenburn.css" />

    <title>reveal.js</title>

    <link rel="stylesheet" href="../../dist/reset.css" />
    <link rel="stylesheet" href="../../dist/reveal.css" />
    <link rel="stylesheet" href="../../dist/theme/black.css" />

    <!-- Theme used for syntax highlighted code -->
    <link rel="stylesheet" href="../../plugin/highlight/monokai.css" />
  </head>
  
  <body>
    <div class="reveal">
      <div class="slides">
        <section>
          <h2>Generics</h2>
          <p style="font-style:italic">"Components that are capable of working on the data of today as well as the
              data of tomorrow will give you the most flexible capabilities for building up large software
              systems"</p>
      </section>
      <section>
          <h3>Let's implement a map</h3>
          <pre><code class="language-typescript">
interface Map {
  get(key: string): Object;
  set(key: string, value: Object): void;
}
          </code></pre>
          <p class="fragment">What's the problem here?</p>
      </section>
      <section>
          <h2>Generics! 🙌</h2>
          <pre><code class="language-typescript">
interface Map&lt;T> {
  get(key: string): T;
  set(key: string, value: T): void;
}
      </code></pre>
      </section>
      <section>
          <h2>top level vs. function generics</h2>
          <pre><code class="language-typescript">
interface Map {
  get&lt;T>(key: string): T;
  set&lt;T>(key: string, value: T): void;
}
          </code></pre>
      </section>
      <section>
          <h2>Another example</h2>
          <pre><code class="language-typescript">class Engine&lt;T>{
  constructor(private runnable: T){}
  run(){
    this.runnable.run();
  }
}</code></pre>
          <div class="fragment">
              <p>Would it work?</p>
              <p>What is the type of T?</p>
          </div>
      </section>
      <section>
          <h2>Generic constrains 💪</h2>
          <pre><code class="language-typescript" data-trim="" data-noescape="">
          interface Runnable {
              run(): void;
          }
          class Engine&lt;T extends Runnable>{
              constructor(private runnable: T) { }
              run() {
                  this.runnable.run();
              }
          }
          </code></pre>
      </section>
      <section>
          <pre><code class="language-typescript">function fetchProperty&lt;T>(object: T, propertyName: string){
  return object[propertyName];
}</code></pre>
          <div>
              <p>Would it work?</p>
              <p>What is the type of T?</p>
          </div>
          <div class="fragment">
              <pre><code class="language-typescript">function fetchProperty&lt;T, PropName extends keyof T>(object: T, propertyName: PropName){
  return object[propertyName];
}</code></pre>
              <p>And now? 💪</p>
          </div>
      </section>
      <section>
          <pre><code class="language-typescript">function animalFactory&lt;T>(Animal: T,){
  return new Animal();
}</code></pre>
          <p>Ok, this deffinitely must work, right?</p>
          <img class="fragment" height="100" style="position: absolute; top:-130px;right:-100px"
              src="../../assets/error1.png" />
          <div class="fragment">
              <pre><code class="language-typescript">function animalFactory&lt;T>(Animal: { new(): T }) {
  return new Animal();
}</code></pre>
              <p>Now it works with class types 💪</p>
          </div>
      </section>
      <section>
          <h2>Lets combine everything</h2>
          <pre><code class="language-typescript" data-noescape="" data-trim="">
          class Animal { }
          interface Runnable {
              run(): void;
          }
          class Cat extends Animal implements Runnable {
              run() { }
          }
          class Dog extends Animal implements Runnable {
              run() { }
          }
          function animalFactory&lt;T extends Animal>(Animal: { new(): T }) {
              return new Animal();
          }
          function startRunning&lt;T extends Runnable>(runnable: T) {
              runnable.run();
          }</code></pre>
      </section>
      <section>
          <h2>Mixins</h2>
          <p>let's add a map</p>
          <pre><code>
const map = new Map&lt;string, string>();
map.set('1', 'something');
map.set('2', 'another thing');
          </code></pre>
          <p class="fragment">
              now let's add a concatinate function to it.
          </p>
      </section>
      <section>
          <h2>take 1</h2>
          <pre><code class="language-typescript">
class ConcatinateableMap extends Map{
  concatinate(): string {
    let total = '';
    for (const value of this.values()) {
        total += value + '\n';
    }

    return total;
  }
}
          </code></pre>
      </section>
      <section>
          <div style="text-align: left;">
              <p style="text-decoration: underline;">pros</p>
              <ul>
                  <li>simple</li>
              </ul>
              <p style="text-decoration: underline;">cons</p>
              <ul>
                  <li>Need to create class for every type of class that has values</li>
              </ul>
          </div>
      </section>
      <section>
          <h2>take 2</h2>
          <pre><code class="language-typescript">class ContainableMap {
  private map = new Map&lt;string, string>();
  concatinate(): string {
    let total = '';
    for (const value of this.map.values()) {
        total += value + '\n';
    }

    return total;
  }
}</code></pre>
      </section>
      <section>
          <div style="text-align: left;">
              <p style="text-decoration: underline;">pros</p>
              <ul>
                  <li>simple</li>
              </ul>
              <p style="text-decoration: underline;">cons</p>
              <ul>
                  <li>Need to create class for every type of class that has values</li>
                  <li>Not really extends the class but hides the map inside</li>
              </ul>
          </div>
      </section>
      <section>
          <h2>take 3</h2>
          <pre><code class="language-typescript">type Constructor<T> = new (...args: any[]) => T;
type ValuesConstructor&lt;ValuesType> = Constructor&lt;{ values: () => IterableIterator&lt;ValuesType> }>;
function getConcatinatableMap&lt;T extends ValuesConstructor&lt;string>>(Base: T) {
return class extends Base {
  concatinate(): string {
      let total = '';
      for (const value of this.values()) {
          total += value + '\n';
      }
      return total;
  }
}
}
const ConcatinatableMap = getConcatinatableMap(Map);
const map = new ConcatinatableMap();
map.concatinate() 🤯</code></pre>
      </section>
      <section>
          <h2>DIY(mixins)</h2>
          <ul>
              <li>create animal class (choose your favorite animal</li>
              <li>create 2 behaviour mixings, one for animals that can fly</li>
              <li>the other for animals that can swim</li>
              <li>give your animal both behaviors</li>
          </ul>
      </section>
      <section>
          <h2>Decorators</h2>
          <p>Generally follows decoration pattern</p>
      </section>
      <section>
          <h2>Decoration Pattern</h2>
          <img height="400" src="../../assets/decoration-pattern.png" />
      </section>
      <section>
          <h2>Decoration Kurzgesagt</h2>
          <h4 style="font-style: italic;">(In a Nutshell)</h4>
          <ul>
              <li>Give execution of a component to another entity</li>
              <li>Another entity executes additional code together with original one</li>
          </ul>
      </section>
      <section>
          <h2>Activating Decorators</h2>
          <pre><code class="language-bash">
"experimentalDecorators": true,
"emitDecoratorMetadata": true, 
          </code></pre>
          <small>In tsconfig.json</small>
      </section>
      <section>
          <h2>Decorators in Typescript (Angular)</h2>
          <pre><code class="language-typescript">
@Injectable()
class UsefulService {
}

@Injectable()
class NeedsService {
  constructor(public service: UsefulService) {}
}
          </code></pre>
      </section>
      <section>
          <h2>Decorators in Typescript (Inversify)</h2>
          <pre><code  class="language-typescript">
@injectable()
class Ninja implements Warrior {
@inject(TYPES.Weapon) private _katana: Weapon;
@inject(TYPES.ThrowableWeapon) private _shuriken: ThrowableWeapon;
public fight() { return this._katana.hit(); }
public sneak() { return this._shuriken.throw(); }
}
          </code></pre>
      </section>
      <section>
          <h2>Decorators Types</h2>
          <h4>(In Typescript)</h4>
          <ul>
              <li>Class</li>
              <li>Property</li>
              <li>Accessor</li>
              <li>Method</li>
              <li>Patameter</li>
          </ul>
      </section>
      <section>
          <h3>Decorator vs. Decorator Factory</h3>
          <ul style="list-style: none;">
              <li>Decorator - creates direct decorator</li>
              <li>Factory - allows customization of decorators</li>
          </ul>
      </section>
      <section>
          <h2>Decorator Factory Example</h2>
          <pre><code class="language-typescript">
function color(value: string) {
// this is the decorator factory, it sets up
// the returned decorator function
  return function (target) {
    // this is the decorator
    // do something with 'target' and 'value'...
  };
}                    
          </code></pre>
          <small>from: <a
                  href="https://www.typescriptlang.org/docs/handbook/decorators.html">https://www.typescriptlang.org/docs/handbook/decorators.htm</a></small>
      </section>
      <section>
          <h2>Class Decorators (implementation)</h2>
          <pre><code class="language-typescript">
function ConstructorPerformance(Constructor: { new(...args: any[]): any }) {
  return class extends Constructor {
    constructor(...args: any[]) {
        const start = new Date();
        super(args);
        const end = new Date();
        console.log(`took ${end.getTime() - start.getTime()}ms to finish construction`);
    }
  }
}
          </code></pre>
      </section>
      <section>
          <h2>Class Decorators (Usage)</h2>
          <pre><code class="language-typescript">
@ConstructorPerformance
class Test {
  constructor(){
    let result = 1
    for (let index = 1; index < 10000; index++) {
        result *= index;
    }
  }
}
const test = new Test();
          </code></pre>
          <pre><code class="language-bash">
took 12ms to finish construction
</code></pre>
      </section>
      <section>
          <h2>Method Decorator (implementation)</h2>
          <pre><code class="language-typescript">
function ExceptionWrapper(target: any, propertyKey: string, descriptor: TypedPropertyDescriptor<(...args: any[]) => void>) {
  const originalFunction  = target[propertyKey];
  descriptor.value = (...args: any[]) => {
    try{
        originalFunction.apply(target, ...args);
    } catch(error){
        const typedError = error as Error
        console.log(`caught exception in wrapper, ${typedError.message}`);
    }
  }
}
          </code></pre>
      </section>
      <section>
          <h2>Method Decorator (usage)</h2>
          <pre><code class="language-typescript">
export class Test {
  @ExceptionWrapper
  throwException(someValue: string) {
    throw new Error(someValue);
  }
}


const t = new Test();
console.log(t.throwException('some string'));
          </code></pre>
      </section>
      <section>
          <h2>Reflection and Metadata</h2>
          <h4>Let's look at the code</h4>
          <pre><code>
__decorate([
ExceptionWrapper,
__metadata("design:type", Function),
__metadata("design:paramtypes", [String]),
__metadata("design:returntype", void 0)
], Test.prototype, "throwException", null);
exports.Test = Test;
const t = new Test();
console.log(t.throwException('some string'));                    
          </code></pre>
          <small>Insufficient reflection</small>
      </section>
      <section>
          <h2>reflect-metadta to the rescue</h2>
          <ul>
              <li><a
                      href="https://www.npmjs.com/package/reflect-metadata">https://www.npmjs.com/package/reflect-metadata</a>
              </li>
              <li>~4M weekly downloads</li>
              <li><a href="https://rbuckton.github.io/reflect-metadata/">Detailed Proposal</a></li>
          </ul>
      </section>
      <section>
          <h2>Reflection with reflect-metadata</h2>
          <pre><code>
import 'reflect-metadata';
function ConstructorPerformance(Constructor: { new(...args: any[]): any }) {
  const start = new Date();
  const metadataKeys = Reflect.getOwnMetadataKeys(Constructor); // ['design:paramtypes']
  const metadataPatamtypes = Reflect.getMetadata('design:paramtypes', Constructor);
  console.log(metadataPatamtypes.map((param:any) => param.name)); // [ 'String', 'Boolean' ]
  return class extends Constructor {
    constructor(...args: any[]) {
        const start = new Date();
        super(args);
        const end = new Date();
        console.log(`took ${end.getTime() - start.getTime()}ms to finish construction`);
    }
  }
}
          </code></pre>
      </section>
      <section>
          <h2>Wait... What about javascript?</h2>
          <p>Javascript decorators are at <a href="https://github.com/tc39/proposal-decorators">stage2</a> </p>
          <p>Which means: The committee expects the feature to be developed and eventually included in the
              standard</p>
      </section>
      <section>
          <h2>DIY (decorators)</h2>
          <ul>
              <li>Create an autologger decorator (method decorator)</li>
              <li>Should log once in a beginning of a function</li>
              <li>Should log all params with their values</li>
          </ul>
      </section>
      <section>
          <h1>done!</h1>
      </section>
      <section>
        <section data-background="#007acc">
          <h4>
          Typescript Basics++
          </h4>
        </section>
      </section>
        <section>
          <p>number 1,2,3</p>
          <p>string 'Hi</p>
          <p>boolean true false</p>
          <p>objects {age:30}</p>
          <p>Array [1,2,3]</p>
        </section>
        <section>
          <section>
            <h4>Tupels</h4>
          </section>
          <section>
            <p>A tuple type is another sort of Array type that knows exactly how many elements it contains, and exactly which types it contains at specific positions.</p>
            <pre><code data-trim data-noescape>
              const role:[string, number]
              </code></pre>
          </section>
					<section  id="fragments" data-background-color="white" data-background-iframe="https://www.typescriptlang.org/play?#code/PTCMDoAJIdwCwIYBdYHsCuAbAJpJBPABwFMBnAYwCcBLQlagOwDNjKB+SAKBEk2JQC2+AJLNUkALyQA2gHIAgqQRNZAGgDM6gLoBuTt2AAmKAd79IQ0U1QAuGaSQ0GAc1WQG6AQCNWWyTIUlFQ1tfR51KBhqTEw8OGpSNEoAaw5TSzFpAAY-KQAiABEEBgZ8PPSRTNBcyELi0vLTABZI6NikeMSYVBS2CqtUcEJ0UjgAClAsrIBKPVMAVlaYuISk1K4eDOt-aS0w4EgANiX2zrW0zcrtqTlFZTVNN0mc-cgAdhO45HONg-JUBgOGRCAByCAExDcCGcxBqW1Qc3SPWIKxciXwGEg5GKkGw4iiHUgCDw6EIfBsrwgJLJZCxOMQADcUag6NQAQhYoRKCzWEhqGRXgQSJAAKLUDqsQzYADylHUuBuHm8rDcSp8lFVnnVbF0pn+gJQ-x62FIoB26imbiaUz2PH1QKNlBNhnNlsg1qybnmNr0doBQOkAA9QG58NV-I6TaA9f6UEHDKGE5AAF6GGqR0iGV7GSAAFVJfES2IYRMwpHEjJRlDIKGIfAhDCQpDc8Go5DgkEreHEPiJJYQlEoCHwwCQBZRQuI4FMCGnPEnkAAyo5GM4QVrWAAhVCoPjFRI3BxOVzuDcayDgS9eHd7hi7XV+g1EuzL4-r5WUbe74j7nZ5bqUDgeRuOobiOOgkKQEwHKkJB4GQdBZZwZQEG6qYXhzgcC6vquX63qQ77qjsR6rm4l7gNe37FLsmofg+fyxpAXgviuLh4T+gKEawf4AUBqjwW4iGwWBKEITByEQSBaF2pheBECi7H7jhLhcZQOzkZRt40ZAJEuLR6r0VijHkHYimAspa5njsAlQeJImSbZSH2ZB-49HxkDaHMPDEIG4I0hSPBMOgDDkHyAKQNWCDYJu6BIEgAKiMMSBjORA7OKQdjSLpJ5qiqF5XjeHH3tMkAAN6mNA9pxgw4KQUylCkGyDBkZejBJTUaWkL6BzQDw5GmAAvvs3RYLgHTfABqSmJF0WxfFDCJbFYyyDVEJqJASbwdMw0YDgXwoJNfQ8DNMVxQlDBJctq3EOtm2ifx914I9QnENtBgjXt40HT0U3HT+s1nQtF1LSttW3W9IAfWNiDfb003-ad82LcloNrRDwC5mcqyIAw2D4LAcDECWGLoLAxQoPFeAIMkKLEgyA7UAgXh8KeH6QKgTBEpQzieETTawOKHbEtWQKEAOtVIHlxS4CT7jEMQuDEgIjDUAInis0RHOQHWxANk2bjobFkCy3iDCAJgEB3k92kCMI4qDYOg5AorbrAQtgjOS5A9M0EzhbTvsEQRf9AKYPggryZAACyVziFIM0h-jWWsTlZ6GXwggx3Y0cDDsgT3CBnmmFD+3nP0mQ5P4shFCU+CyFw+wtJAAAKCCkI1LhEtSLOt53IsoGLQ4CNbxJBSFYUMAFDFPniy7oEwnNSGMpgAJCpdzGUyOR10b9l2kr6Mu3YAAwgghDihy1DJsQdiaRxtoHNMdgMqg1AKgAfGVK88HiOljvP-U8CGqYGef8mBjBettb+qBZ7zzGHkFgxBgK1CYNQJB8DUBoKCgIYCW09BAA" data-background-interactive>
          </section>
            <section id="fragments">
            <h4>Summary</h4>
            <p class="fragment"> Tuples are not inferred by typescript they have to be declared.</p>
            <p class="fragment">Event when a tuple is declared (with fixed length) it is still possible to push data to it.</p>
            <p class="fragment">a tuple can have an optional value at the end</p>
            <p class="fragment">a tuple can have a rest param at any place</p>
            <p class="fragment">the last can be used in order to pass deferent types to one function as one parameter</p>
          </section>
        </section>
        <section>
          <section>
            <h4>Enums</h4>
          </section>
          <section>
            <p>Enums are one of the few features TypeScript has which is not a type-level extension of JavaScript.</p>
            <p>Enums allow a developer to define a set of named constants. Using enums can make it easier to document intent, or create a set of distinct cases. TypeScript provides both numeric and string-based enums.</p>
          </section>
          <section  id="fragments" data-background-color="white" data-background-iframe="https://www.typescriptlang.org/play?#code/PTAEFMA8EMFsAcA25QEYBcoBQJQGMB7AOwGcAXUAQQBEBZASQDlQBeUABhzENIoCUAojQD6AeUYAZAJqs0XfMXJUAqgBUAEqL6yATAG4s8nkviyA3vNBXQROOEwAiSiWgAzBwBpL16AHN7oADMgV641qAATgTImDQMjPIAvoa4AO4AloiIoGQAFtAUqQQRANYA-Ni48AB0UciyAKwpYFBwSCg6mIwArrDgEel4EES9JPLgI7CgfNEoFmHWcUyhYOGCIuLSK+EqGlpJzQq8oKZs86vWtn2Ozm6e3lZ+AcHb4XUBM8jVSwm4yWmZbJ5AqgIqlCryGrvRqGQ6tBD1QKYADKZAGRF8w1G40m01moHOOx+rCcdCY9wWVnW1DEkhkbAc1Np0gpFyslDUmj4DI5ez4DgOh2MFFOBIeNjsoHQDmgLncrx8-kwL3F70wn3A3zJvzAyXkGSyOXyhWK5UqYCh+LYTSqtStoActFEAGEANLCPiiCQCAW26E87W+i12+psDVa+JwmAIlAAFnQ8nSJCNIImvVAADdoIh0gATCG4NNTDViylUbWNBVUoQ0zZSKu7LmCwvR9qgBoJ3BJlMUIuZ7N5gstXElwnhYkB+KsnZMusN3lNv5Rtr1ABsmETyeBvdxWZz+fNWOL+LHiwr1obs7pslQ7HY885WlkTkf-Ob3EUIvM4quKGlsruBsnmVEJVVmdVZgjJh31BQEe1BU0hxOEMUGtSEUOfJ03Q9L0fXQ-0HR+INkII8MfiAA" data-background-interactive>
          </section>
          <section id="fragments">
            <h4>Summary</h4>
            <p class="fragment"> Numeric enums have auto-incrementing behavior</p>
            <p class="fragment">string enums don’t have auto-incrementing behavior</p>
            <p class="fragment">String enums allow you to give a meaningful and readable value when your code runs</p>
          </section>
        </section>
        <section>
          <section>
            <h4>Union Types</h4>
          </section>
          <section id="fragments">
            <p class="fragment">A union type is a type formed from two or more other types, representing values that may be any one of those types.</p>
            <p class="fragment">We refer to each of these types as the union’s members.</p>
          </section>
          <section  id="fragments" data-background-color="white" data-background-iframe="https://www.typescriptlang.org/play?#code/PTCmA8EMFsAcBtQAICMAuAUCJAzArgHYDGALgJYD2BSRF0ARmQaABROx4npIF4OgAnADRJ2nAExoefeoICUAbyzAkq1QNAk8A6mK5IA1KIIcS45UgC+ygO4U88ACZISAC0gkkdgQGsA-Ba0BADOnrQMTKDOALw0dIzMLChC4nIYyhAwCMiSFvjE5FRxEYl63KECTADmInqSSBXVihZqSBpaOsamKIZdEhbWIHYOzm4eXhS+AdhBocUJUUix4QssAEQAgsGQOGsiawBykJMAnmtpGVBwiEgAzJjYw04u7p7e-nmEpJTUK5FsJk45RIlQIVQAPtJ+MI+mYpI0wZDeNDmthWu1tLpAfojHUBulsJlrsgACxST4FH7zf5leEg6pImSCWrY+oIiFQ2QCVEqVpkHAsEgnWCgCg4WE9aKxADkyK50qQADJFS5haLxXUljK5YIFTzWgaMZ0yr08Wi1INeWojVjugA6EgUADK9LBLDkptZDudrqq+KG9meYzekw+Myocz+zBi1MSyVSgQjYXikRjUdYm22u32R1O5wJKiJ2SQAFZyQGRi9xu9pip8t8irBQSQAJKONiOKQ6gRISHsj1Kc2zCiIO3wChVDvegCqsBFAgAwpBgqw5HIANz4ixFm4ANnLwCeo1eEymFIb1CbTFb7bInc5gl7DV9A5aonFgrVYtEMSlSDW7LnEgg5Wqo2AttQbhkMESD0AIkDEK4tTONBSDfkKIpINK7LSm+qjDqO46TneM5zoIS4ru6G5vpYSCgPAK7AXhSDYAAEoIoDIaIMHoWqWHdrh5r4RGI6gGOE4dtR5qWlY6RyfJCmKYpQA" data-background-interactive>
          </section>
          <section id="fragments">
            <h4>Summary</h4>
            <p class="fragment">A union type is a type formed from two or more other types, representing values that may be any one of those types.</p>
            <p class="fragment">TypeScript can deduce a more specific type for a value based on the structure of the code.</p>
            <p class="fragment">this pattern is called "Narrowing".</p>
            <p class="fragment">If there is a realationship between input and output, use function overloading.</p>
          </section>
        </section>
        <section>
          <section>
            <h4> Literal Types</h4>
          </section>
          <section id="fragments">
            <p class="fragment">In addition to the general types string and number, we can refer to specific strings and numbers in type positions.</p>
            <p class="fragment">By themselves, literal types aren’t very valuable</p>
            <p class="fragment">But by combining literals into unions, you can express a much more useful concept - for example, functions that only accept a certain set of known values</p>
          </section>
          <section  id="fragments" data-background-color="white" data-background-iframe="https://www.typescriptlang.org/play?#code/PTAEFMA8EMFsAcA25QEYBcAoEoDuALaAF1AEsBnUI-FIgT3hQHsAzUAIwH5RNRkT2oALygA5O1EBuTNjBQ4SFACYsOAsTKVqtBszbQANFVDQAdgBNQpgK6xumAMZNT5EtGFjoUx89fGRRABO1uDSTi4kNrAeqNKyEDAIyKAqmCzWpg5EpM6g8IGkpkQAKlBEABTk6KCuBaYA5kbQiKT1prDgRdUARMgsRN2gAD6g3QX1+APDow6dROCB3QCUoADevKA4AHQ7mAC+8bikiIhUhCS4TIEA1pzx+YUlZeXdABLgJ0xGl4GI5t1GXrgfrLOI4fBMXAmdhMawkajEO44B5FUqQCrdADionM0DoRlgxHAAJmc0CxKWYLkiUUoAAzKAALSgOiw0AOMzspiwdiFWg0cgoI7UKzORkteaBZpUXRVGSPBYsaCzUAAeXg2V8aw2R3M1GqUXYC2kB3SmU1pi5phYrWs5PKkGq6otlBG3WgcKYy21oE2YB2W32h2OpwRFyut3i4Rt9Tt4HKqzwpD1+GqqAADOnQHtKTJwZDobD4eckWBo7b7e7PaC82AIVDoDC4WdEVHnDG4y8PURucRSA4a-F5EkUAAWarxeiMcgOAoa9mcpwj+Ys2GBKhlPA0S2s6ygayCshENIZLI5S1L3mmeOFeBwjA1IKFerTQ0LIy3uEqR91F8jN+BEY5LkNYiBEAAws4ABuCzkOe1SiNA5CMgBojTIhyHzOiogrOsvq+qQLDlFO4CsGQph3kQqDCCIoioaAABkDEyowZGfkQSg0WI9FMaAwGgRB0GweeXEYShthGoEOF4fhsnkkQdqWgA1Ox1FKaAKkUV+Gy+gccngApgSWqpWw9gAyk+DTlCs6nsUoplMBZv7WUGwYnC24Y3KWXI8ny5SoEYShGGJb44TIQA" data-background-interactive>
          </section>
            <section id="fragments">
            <h4>Summary</h4>
            <p class="fragment"> Literal Types are inffered by TS when using const</p>
            <p class="fragment"> TThey are valuable when using in Union Types</p>
          </section>
        </section>
        <section>
          <section>
            <h4>Union Types vs Enums</h4>
          </section>
          <section  id="fragments" data-background-color="white" data-background-iframe="https://www.typescriptlang.org/play?#code/PTAEEYDpQdwQwBYBdYHsCuAbAJqBcAHAgUwDtQBLcgKzgDc4BnAYwCcKCkB+AKCQE8SoAGrEEFZpmIAVQcQCqpCqnIBeUAHIAyvOEbQAH01aAogBEAggDl9RjdIBK8gMIBpDQG4eZdAFsRYhJSsiQmpH6gAN48oKA6wgA0MXHm1kmxji6uSQC+PPkgoABMkDyFAJJmJnhMoHDoSKjMqL4EUkjEPABm6KTMSMrkXaio4KAAFL78znCs4ABcAeKSMnKKgwmgUzOsRYuiy8FyYX4AlNGxsRRdk9OzY6qPxqk253mXlDfbs0Wgj+oHIKrULhXyQUyWKxvHh5MrAADMpRAMAwOFASHwKBRrAA1rxCs1SIwUMx7qB9oEViFiCd-OoigAGLxwuCkXAYuDcOGgQnEnk-clLIHU9YqP6aDrEzwFMAAFlAjFQmAagy4XHm3lBQqpci0SHYpAA5rSosl4uLtLoNOkUpCLRDrNbkpk3BaXe5cvken0BmLhqhfrcdgttUcSHqDcbQedklcvnc5n8noCdeH9VQo35wS9obDCgBWaAwCgY0C9QaMUD8DD88joRjELaoViNgQkSsc8jEyOMbkorDszFoXH4sBtxvOADyABlJw4tBaHOZbJoAELT+QmFcMwygADaAF1mYVWYPOcO8dyfP4p7P56bCrEl2ZF8uko-QOvNxav1v32BYgsBwHAsABNcVD25PMwAANiLVEzyxZs8VAblhlYCZeRQcdKHIFMwxpaMHwAnkVEVKRIEwVBDXGcdTi8QpoNAScACNqGIfpIBxYh+EYcZ8OBQizkgdCTDgZgEHGcZuP4U4-gAPmIy5eSVYhKOo8YNBkzRNhk+ioNOGU6jZdFMVHUB0MwsjsLkXDQ0E0VSDk6IPxUiiqJouiGLAJjWPYziZL4gSRSUFRThE5sxIkqS9IUpTYjctSPM07TrVAPTvNAHJTiAA" data-background-interactive>
          </section>
          <section>
            <h1>  narowing example - redux </h1>
          </section>
          <section id="fragments">
            <h4>Summary</h4>
            <p class="fragment">If you are looking to optimize your code and reduce the bundle size at the moment of compiling into JavaScript - union types</p>
            <p class="fragment">If you will be needed to run iterations over a set of values, enums are the way to go</p>
            <p class="fragment">If you have only 2 options, I think unions are better</p>
            <p class="fragment">If you have more than 2-3 options, Enums are better</p>
            <p class="fragment">If you don't have a very good reason not to, use string Enums</p>
          </section>
        </section>
        <section>
          <section>
            <h4>Type Guards and Narrowing</h4>
          </section>
          <section id="fragments">
            <p>what is narrowing?</p>
            <p class="fragment">TypeScript follows possible paths of execution that our programs can take to analyze the most specific possible type of a value at a given position. It looks at these special checks (called type guards) and assignments, and the process of refining types to more specific types than declared is called narrowing</p>
          </section>
          <section id="fragments">
            <p>1. The instanceof keyword</p>
            <p class="fragment">2. The typeof keyword</p>
            <p class="fragment">3. The in keyword</p>
            <p class="fragment">4. Equality narrowing type guard</p>
            <p class="fragment">5. Custom type guard with predicate</p>
          </section>
          <section  id="fragments" data-background-color="white" data-background-iframe="https://www.typescriptlang.org/play?#code/PTAEEYDpQFQCwKagJYDsDOAXAhqgxggPYBmomAngA5IDmArtgE4AmAUHgDbbrqgCy5AMJceoAN6tQU0HkIZMjOnkyFGACkp0ARh2R5QqbAFsEALlBZGaGgBpQmnXtDYaZg3SNaEjAJRiAvqyB7HJYoCagALwGCADu-EIi6GoA5ACC6NjEKXYAzLk+ANysrCCgAOpw2JigsYR0HMygXmSIoPU1mpgA-KzEdPiYyHKgxISEoGom5gMA1qiEsag+4qzIxFNIaFi4BCQJwtzofpLSZ7IYhBwIkByENKnbOPhEpAKHPCk+p2dSZXUNJqYKo1OqMWbdUA-X5lC7oK43O4PcI3QwmOwmSAuBDfM6BM4IDjoJASX7SOEI273VILGpPXavA5JL7Qs7-eqNVrVWqqCFQsl-MAU65Uh6YtEIDE3bG46SBYJlABMoEg8CQFGo+w1tAYLD6A2Uw1QoAAypg6MwEKhMABJZhqAAe5ks1lAAB93J5vDYVqTpOtJtr9g6otEUi7UDQvqsBTJQpSkakzRarZgvsVY+y6MhOcDuWCIazpGUHZA0JwU+gi4KedncyCeeDepmwKW0JaHQB5YjQ-H+0hqIOkEORUegFKoDxeRjRv1k4WI6kpO3p6ugLP1-O85sCkuQFRmqyRtSyqTykplXLQNUoY3a0D0JhsNCYbzEbAEUAAEXuMekEudBRrBsaEtCYWZAKPGggjWa03w-JAABkjT-KQAIsIDIxAs5GEIJhIOsGCX3gz9BEWVCDGMNwI1saEjHGAjIxg-VBhQ3BkCMbAOD4bBZgQAA5QhkGJNR2M4jhzB-Gh3VAZCRg9MjYhOM51lSMDwRSW9nFQDiuOUgUF1FVJyhIUg6mIbJT1APspEJYkUA2FJcKYTS0G03SOH0+d4xFRMUgAJTwxhgsYABCUKWTxaE7K2Rz6MIVzjTEvS51+Qy-PiwhwsiuVmLKAAWaAAFEAEcGF0ChKOCxZXXvR89X6ViRgQB1jEoa5HUY6SPUnL1GDscgupkrRxmuXBfVOANHVDaJyAmtkwHKJA8FwAxyJWjgOG08hxxozSTGBQgmhGFIHU01Rx3IFJIGhaFSxUABVShqEYQRuAQE8M2LMBNkO5gVkPax90IJ6XrekSfC6koznIYHEMWbxwY+ooyWhMpfrgI6Acwmg4YR173pPKHTn8UAYoo9LqQdFHYykNGfsoJgqNfXxQCdDCoJk3rp2h8kfMXB45sKWm6YWyZGcYZnvBWQaOddD0RoRXBefPUpgAAVmgQQ6CwQgjDIKgdSfWpkGBexGAQZg9GqBBWHvAAxYS4CicQLFiDjzBPKIAD5QAANyEpp-GKe8ACFkBYF2xFGDhZa9yJfYD5Ag+KRrDRGVxMBNcSOAABQQTAT1SuEakl1BmD1l2eOBSAy4rowT2hVS68r32AAZIHVrzfgt81GGNMR0HdoxPZ8BPxEph5w2Hr5-Bs6zoV7uh+-EYhY9H8exEn1I16unw57ysBQ8IM2NqJMgJmnjjNNwJoUl3m+LbW+JCFmbBYdYa5OgLl3M+zri84F0+iES4vlqTUEwN8bewlHboDgBoAuPhvhrAHDAp2CDIHzXsAXSAQ8OLANJuTP0EDIC7wIWrWAbR7yUAtlbFar5sF0l4LA527tNrhF4kgGAhsTR4CsJQUulslDqioYbC+oAWG3iwAgbAx1SBL37q6AAVjrGo2BmijRkcaP2XE6A3BYunY0aC4EYPMJIj04cWCQ0YSgZhTs-wKONBg5wdi4E+FwcPUAoUxwDEtMQNAltij+CAA" data-background-interactive>
          </section>
          <section>
            <p>what is the problem with this?</p>
            <pre><code data-trim data-noescape>
              catch (e) {
                console.log((e as Error).message)
              }
            </code></pre>
          </section>
          <section>
            <p>Solutions</p>
            <pre><code data-trim data-noescape>
              catch (err) {
                if (err instanceof Error) {
                  console.log(err.message);
                } else {
                  console.log('Unexpected error', err);
                }
            </code></pre>
            <pre><code data-trim data-noescape>
              catch (err) {
                if ("message" in err) {
                  console.log(err.message);
                } else {
                  console.log('Unexpected error', err);
                }
            </code></pre>
          </section>
        </section>
        <section data-background="#007acc">
          <h4>
            Things you should have known in TypeScript but you
            probably don't
          </h4>
          </section>
        </section>
        <section data-background="#007acc">
          <section>
            <h4>string, number or boolean literal as a type</h4> 
            <aside class="notes">
              A literal is a more concrete sub-type of a collective type. What
              this means is that "Hello World" is a string, but a string is not
              "Hello World" inside the type system.
            </aside>
          </section>
          <section id="fragments">
            <p>
              1. strings
            </p>
            <p class="fragment">

              2. numbers
            </p>
            <p class="fragment">
              3. booleans
            </p>
            <aside class="notes">
            There are three sets of literal types available in TypeScript today:
            strings, numbers, and booleans; by using literal types you can allow
            an exact value which a string, number, or boolean
          </aside>
          </section>
          <section id="fragments">
           <p> for instance if a create a variable </p> 
            <pre class="fragment"><code data-trim data-noescape>
				const number = 23 
			</code></pre>
          <aside class="notes">
              TypeScript will infer the type of this const as 23 (and not a number
              in general) since it is a const and it will never change!
            </aside>
          </section>
          <section data-background="#007acc">
            <h2 data-id="code-title">For example:</h2>
            <pre><code class="typescript-language" data-trim data-noescape>
				type Asaf = 'Asaf';
				
				// no error
				const name: Asaf = 'Asaf'
				const age: 32 = 32
		
				// error
				
				// Type '"Niv"' is not assignable to type '"Asaf"'
				const name: Asaf = 'Niv'
				
				// Type '40' is not assignable to type '32'
				const age: 32 = 40
			</code></pre>
          </section>
          <section>
            <h2 data-id="code-title">For example - consider the next function:</h2>
            <pre><code data-trim data-noescape>
			const combine = (
				input1: number , 
				input2: number, 
				resultConversion: string
			) => {
				if(resultConversion === "as-number"){
					return input1 + input2;
				}
				else{
					const res = input1 + input2;
					return res.toString();
				}
			}
			</code></pre>
          </section>
          <section>
            <pre><code data-trim data-noescape data-line-numbers="4">
			const combine = (
				input1: number , 
				input2: number, 
				resultConversion: 'as-string' | 'as-number'
			) => {
				if(resultConversion === as-number){
					return input1 + input2;
				}
				else{
					const res = input1 + input2;
					return res.toString();
				}
			}
			</code></pre>
          </section>
          <section>
            <h2 data-id="code-title">For example:</h2>
            <pre><code data-trim data-noescape data-line-numbers="1,5, 15, 17">
			type ResultConversion =  'as-string' | 'as-number'
			const combine = (
				input1: number , 
				input2: number, 
				resultConversion: ResultConversion
			) => {
				if(resultConversion === "as-number"){
					return input1 + input2;
				}
				else{
					const res = input1 + input2;
					return res.toString();
				}
			}
			</code></pre>
          </section>
          <section id="fragments">
            <aside class="notes"> 
              in this way we can both prevent other people from sending
              unrealted strings to this function and prevent typos like
              "as-strnig".
            </aside>

            <p class="fragment">any other string will not be alowed.</p>

            <p class="fragment">most of the time it will be used in a Union type</p>

            <pre class="fragment"><code data-trim data-noescape>
				combine(1, 2, 'as-string') // 3 
				combine(1, 2, 'as-strnig')
			 // Argument of type '"as-strnig"' is not assignable to parameter oftype 'ResultConversion'.(2345)
			</code></pre>
          </section>
          <section>
            <h1>Quiz</h1>
          </section>
          <section>
            <p> What can not be a literal type?</p>
            <p>1. String </p>
            <p>2. Number </p>
            <p>3. Array </p>
            <p>4. Boolean </p>
          </section>
          <section>
            <p> What will be the type of this expression? </p>
            <pre><code data-trim data-noescape>
              const name = 'name'
            </code></pre>
          </section>
        </section>
        <section data-background="#007acc">
          <section>
            <h4>Rest params in function parameters and Tuples</h4>
          </section>
          <section>
            <aside class="notes"> 
              A rest parameter allows you a function to accept zero or more
              arguments of the specified type. In TypeScript, rest parameters
              follow these rules:
            </aside>

            <p >1. A function has only one rest parameter.</p>
            <p class="fragment">2. The rest parameter appears last in the parameter list.</p>
            <p class="fragment">3. The type of the rest parameter is an array type.</p>

            <pre class="fragment"><code data-trim data-noescape>
				function fn(...rest: type[]) {
					//...
				 }
			</code></pre>
          </section>
          <section>
            <pre><code data-trim data-noescape>
				function getTotal(...numbers: number[]): number {
					let total = 0;
					numbers.forEach((num) => total += num);
					return total;
				}
			</code></pre>
          </section>
          <section>
            <pre><code data-trim data-noescape>
            console.log(getTotal()); // 0
            console.log(getTotal(10, 20)); // 30
            console.log(getTotal(10, 20, 30)); // 60
          </code></pre>
          </section>

          <section id="fragments">
            <aside class="notes"> 
              Rest params can be used an Tuples as well
              
              Tuple types allow you to express an array with a fixed number of
              elements whose types are known, but need not be the same.
            </aside>
              <pre><code data-trim data-noescape>
                // Declare a tuple type
                let x: [string, number];
                // Initialize it
                x = ["hello", 10]; // OK
                // Initialize it incorrectly
                x = [10, "hello"]; // Error
                
                // A tuple with a *rest element* - holds at least 2 strings at the front,
                // and any number of booleans at the back.
                let e: [string, string, ...boolean[]];
                
                e = ["hello", "world"];
                e = ["hello", "world", false];
                e = ["hello", "world", true, false, true];
              </code></pre>
            </section>
          <section>
            <aside class="notes"> 
              In TypeScript 4.2, rest elements specifically been expanded in how
              they can be used. In prior versions, TypeScript only allowed
              ...rest elements at the very last position of a tuple type.

              However, now rest elements can occur anywhere within a tuple -
              with only a few restrictions.
              </aside>
            <pre><code data-trim data-noescape>			
				let foo: [...string[], number];
		
				foo = [123];
				foo = ["hello", 123];
				foo = ["hello!", "hello!", "hello!", 123];
		
				let bar: [boolean, ...string[], boolean];
		
				bar = [true, false];
				bar = [true, "some text", false];
				bar = [true, "some", "separated", "text", false];
				</code></pre>
        </section>
        <section id="fragments">
            <aside class="notes"> 
              The only restriction is that a rest element can be placed anywhere
              in a tuple, so long as it’s not followed by another optional
              element or rest element.

              In other words, only one rest element per tuple, and no optional
              elements after rest elements.
              </aside>
            <pre><code data-trim data-noescape>		
				interface Clown {
					/*...*/
				  }
				  interface Joker {
					/*...*/
				  }
				   
				  let StealersWheel: [...Clown[], "me", ...Joker[]];
				  // A rest element cannot follow another rest element.
				   
				  let StringsAndMaybeBoolean: [...string[], boolean?];
				  // An optional element cannot follow a rest element.	
			</code></pre>
          </section>
          <section id="fragments">
            <aside class="notes"> 
              These non-trailing rest elements can be used to model functions
              that take any number of leading arguments, followed by a few fixed
              ones.
            </aside>
            <pre class="fragments"><code data-trim data-noescape>		
				const doStuff = (
					...args: [...names: string[], 
					shouldCapitalize: boolean]
				) void => {
					// do stuff...
				}
 
				doStuff(false)
				doStuff("fee", "fi", "fo", "fum",true);
			</code></pre>
          </section>
          <section>
            <h1>Quiz</h1>
          </section>
          <section>
            <p> which of these is not correct? </p>
            <pre class="fragment"><code data-trim data-noescape>let bar:[...number[], boolean]	</code></pre>
            <pre class="fragment"><code data-trim data-noescape>	function foo(bool: boolean, num: number, ...rest: string[])</code></pre>
            <pre class="fragment"><code data-trim data-noescape> let x:[...number, string?]	</code></pre></p>
            <pre class="fragment"><code data-trim data-noescape>	
              const func =
               (...args:[...phoneNumbers :number[], shouldBeCalled:boolean])
              :void => {}</code></pre>
          </section>
        </section>
        <section data-background="#007acc">
          <section>
            <h4>Union types</h4>
            <aside class="notes"> 
              A union type describes a value that can be one of several types.
              We use the vertical bar (|) to separate each type, so number |
              string | boolean is the type of a value that can be a number, a
              string, or a boolean.
           </aside>
          </section>
          <section>
            <pre><code data-trim data-noescape>		
					interface Bird {
						fly(): void;
						layEggs(): void;
					  }
					   
					  interface Fish {
						swim(): void;
						layEggs(): void;
					  }
					   
					  declare function getSmallPet(): Fish | Bird;
					   
					  let pet = getSmallPet();
					  pet.layEggs();
					   
					  // Only available in one of the two possible types
					  pet.swim();
					  /* Property 'swim' does not exist on type 'Bird | Fish'.
						roperty 'swim' does not exist on type 'Bird'.*/
				</code></pre>
        <aside class="notes"> 
            Union types can be a bit tricky here, but it just takes a bit of
            intuition to get used to. If a value has the type A | B, we only
            know for certain that it has members that both A and B have. In
            this example, Bird has a member named fly. We can’t be sure
            whether a variable typed as Bird | Fish has a fly method. If the
            variable is really a Fish at runtime, then calling pet.fly() will
          fail.
        </aside>
          </section>
          <section>
            <h4>Discriminating Unions</h4>
            <aside class="notes"> 
              A common technique for working with unions is to have a single
              field which uses literal types which you can use to let TypeScript
              narrow down the possible current type. For example, we’re going to
              create a union of three types which have a single shared field.
            </aside>
          </section>
          <section data-auto-animate>
            <pre data-id="code-animation" ><code class="hljs" data-trim data-line-numbers="|1-15|16,17|18-21">	<script type="text/template">
				type NetworkLoadingState = {
					state: "loading";
				  };
				  type NetworkFailedState = {
					state: "failed";
					code: number;
				  };
				  type NetworkSuccessState = {
					state: "success";
					response: {
					  title: string;
					  duration: number;
					  summary: string;
					};
				  };
				  // Create a type which represents only one of the above types
				  // but you aren't sure which it is yet.
				  type NetworkState =
					| NetworkLoadingState
					| NetworkFailedState
					| NetworkSuccessState;
				</script></code></pre>
          </section>
          <section id="fragments">
            <aside class="notes"> 
              In this case, you can use a switch statement to narrow down which
              type is represented at runtime:

              By switching on state, TypeScript can narrow the union down in code flow analysis
            </aside>
            <pre><code class="hljs" data-trim data-line-numbers="|1-4|6|8-10|11-20">		
				type NetworkState =
					| NetworkLoadingState
					| NetworkFailedState
					| NetworkSuccessState;

					function logger(state: NetworkState): string {

            // Trying to access a property which isn't shared
            // across all types will raise an error
            state.code;

					switch (state.state) {
					case "loading":
						return "Downloading...";
					case "failed":
						return `Error ${state.code} downloading`;
					case "success":
						return `Downloaded ${state.response.title} - ${state.response.summary}`;
						}
					}
				</code></pre>
          </section>
          <section id="fragments">
            <h1>Quiz</h1>
            <p>consider the next types</p>
            <pre class="fragment" data-id="code-animation" ><code class="hljs">	<script type="text/template">
              type TypeOne = {
                name: 'one';
                age: number;
              }
            </script></code></pre>
            <pre class="fragment" data-id="code-animation" ><code class="hljs">	<script type="text/template">
              type TypeTwo = {
                name: 'two';
                address: string;
              }
            </script></code></pre>
            </section>
            <section>
            <pre class="fragment" data-id="code-animation" ><code class="hljs">	<script type="text/template">
              type OneAndTwo = TypeOne | TypeTwo
            </script></code></pre>
            <pre class="fragment" data-id="code-animation" ><code class="hljs">	<script type="text/template">
              function foo(bar: OneAndTwo): void {
                // valid?
                if(bar.name === 'one'){
                  console.log(bar.age)
                }

                // valid?
                if(bar.name === 'two'){
                  console.log(bar.age)
                }

                // valid?
                if(bar.name === 'two'){
                  console.log(bar.address)
                }
              }
            </script></code></pre>
            </section>
          </section>
        </section>
        <section data-background="#007acc">
          <section>
            <h4>Type vs Interface</h4>
          </section>
          <section>
            <p>Interface</p>
            <aside class="notes"> 
              One of TypeScript’s core principles is that type checking focuses
              on the shape that values have. This is sometimes called “duck
              typing” or “structural subtyping”. In TypeScript, interfaces fill
              the role of naming these types, and are a powerful way of defining
              contracts within your code as well as contracts with code outside
              of your project.
            </aside>
          </section>
          <section>
            <p>1. Interfaces can be extended and implemented</p>
            <pre><code  class="hljs" data-trim data-line-numbers="|1-5|7-11|13|15-17|19-24">		
              interface Person {
                name: string,
                age: number
                sayHello:() => void
              }
              
              class SomePerson implements Person {
                name ='Asaf'
                age = 32
                sayHello () {console.log('Hello')}
              }

              const p = new SomePerson();
              
              interface Developer extends Person{
                typescriptMaster: boolean
              }
              
              const me: Developer = {
                  name: 'Asaf',
                  age: 32,
                  typescriptMaster: true,
                  sayHello: () => console.log('Hello')
              }
				</code></pre>
          </section>
          <section>
            <p>2. Declaration merging</p>
            <aside class="notes"> 
              “declaration merging” means that the compiler merges two separate
              declarations declared with the same name into a single definition.
              This merged definition has the features of both of the original
              declarations. Any number of declarations can be merged; it’s not
              limited to just two declarations.
            </aside>
          </section>
          <section>
            <pre><code data-trim data-noescape>		
					interface Box {
						height: number;
						width: number;
					  }

					  interface Box {
						scale: number;
					  }

					  let box: Box = { height: 5, width: 6, scale: 10 };
				</code></pre>
          </section>
          <section>
            <p>Type alias</p>
            <aside class="notes"> 
              it’s common to want to use the same type more than once and refer
              to it by a single name. A type alias is exactly that - a name for
              any type. The syntax for a type alias is:
            </aside>
          </section>
          <section>
            <p>1. types can not be extended - types intersection</p>
            <pre><code data-trim data-noescape>		
					type Person = {
						name: string,
						age: number
					} &  { typescriptMaster: boolean }
					
					const me: Person = {
						name: 'Asaf',
						age: 32,
						typescriptMaster: true
					}
				</code></pre>
          </section>
          <section>
            <p>2. Union types</p>
            <p></p>
            <pre><code data-trim data-noescape>		
						type Person = {
							name: string,
							age: number
						} 
						
						type TypescriptMaster = { typescriptMaster: boolean }

						type Asaf = Person | TypescriptMaster 
						
						const me: Asaf = {
							name: 'Asaf',
							age: 32,
						}

						// or 
						const me: Asaf = {
							typescriptMaster: true;
						}

						// or
						const me: Asaf = {
							name: 'Asaf',
							age: 32,
							typescriptMaster: true;
						}
					</code></pre>
          <aside class="notes"> 
           We can not create an interface which is a union of other 2 interfaces or types
          </aside>
          </section>
        </section>
        <section data-background="#007acc">
          <section >
           <h4> type never </h4> 
           <aside class="notes">
            The never type represents the type of values that never occur. For
            instance, never is the return type for a function expression or an
            arrow function expression that always throws an exception or one
            that never returns. Variables also acquire the type never when
            narrowed by any type guards that can never be true. The never type
            is a subtype of, and assignable to, every type; however, no type
            is a subtype of, or assignable to, never (except never itself).
            Even any isn’t assignable to never.
           </aside>
          </section>
          <section>
            <pre><code data-trim data-noescape>		
				// Function returning never must not have a reachable end point
				function error(message: string): never {
				  throw new Error(message);
				}
				 
				// Inferred return type is never
				function fail() {
				  return error("Something failed");
				}
				 
				// Function returning never must not have a reachable end point
				function infiniteLoop(): never {
				  while (true) {}
				}
			</code></pre>
          </section>
          <section>
            <h4> type unknown</h4>
            <aside class="notes"> 
              the unknown type is simmilar to the any type, however you can't
              assign a value of type unknown to another value with different
              type without type check (typeof) first.

              Anything is assignable to unknown, 
              but unknown isn’t assignable to anything but itself and any without a type assertion or a control flow based narrowing.
              Likewise, no operations are permitted on an unknown without first asserting or narrowing to a more specific type.
            </aside>
          </section>
          <section>
            <aside class="notes"> 
              Here's a list of assignment examples we saw before, this time using a variable typed as unknown:
            </aside>
            <pre><code data-trim data-noescape>		
              let value: unknown;

              value = true; // OK
              value = 42; // OK
              value = "Hello World"; // OK
              value = []; // OK
              value = {}; // OK
              value = Math.random; // OK
              value = null; // OK
              value = undefined; // OK
              value = new TypeError(); // OK
              value = Symbol("type"); // OK
		</code></pre>
          </section>
          <section>
            <aside class="notes"> 
              What happens though when we try to assign a value of type unknown to variables of other types?
            </aside>
            <pre><code data-trim data-noescape>	
            let value: unknown;

            let value1: unknown = value; // OK
            let value2: any = value; // OK
            let value3: boolean = value; // Error
            let value4: number = value; // Error
            let value5: string = value; // Error
            let value6: object = value; // Error
            let value7: any[] = value; // Error
            let value8: Function = value; // Error
            </code></pre>
          </section>
          <section>
            <aside class="notes"> 
              We can narrow the unknown type to a more specific type in different ways, including the typeof operator, 
              the instanceof operator, and custom type guard functions. All of these narrowing techniques contribute to TypeScript's control flow based type analysis.

              The following example illustrates how value has a more specific type within the two if statement branches:
            </aside>
            <pre><code data-trim data-noescape>	
              function stringifyForLogging(value: unknown): string {
                if (typeof value === "string") {
                  return value
                }
                if (typeof value === "function") {
                  // Within this branch, `value` has type `Function`,
                  // so we can access the function's `name` property
                  const functionName = value.name || "(anonymous)";
                  return `[function ${functionName}]`;
                }
              
                if (value instanceof Date) {
                  // Within this branch, `value` has type `Date`,
                  // so we can call the `toISOString` method
                  return value.toISOString();
                }
              
                return String(value);
              }
            </code></pre>
          </section>
          <section>
            <p>If you want to force the compiler to trust you that a value of type unknown is of a given type, you can use a type assertion like this:</p>
            <pre><code data-trim data-noescape>	
              const value: unknown = "Hello World";
              const someString: string = value as string;
              const otherString = someString.toUpperCase(); // "HELLO WORLD"
            </code></pre>
            <p>This can easily lead to an error being thrown at runtime if you make a mistake and specify an incorrect type:</p>
            <pre><code data-trim data-noescape>	
              const value: unknown = 42;
              const someString: string = value as string;
              const otherString = someString.toUpperCase(); // BOOM
            </code></pre>
          </section>
          <section>
            <p>In a union type, unknown absorbs every type. This means that if any of the constituent types is unknown, the union type evaluates to unknown:</p>
            <pre><code data-trim data-noescape>	
              type UnionType1 = unknown | null; // unknown
              type UnionType2 = unknown | undefined; // unknown
              type UnionType3 = unknown | string; // unknown
              type UnionType4 = unknown | number[]; // unknown

              type UnionType5 = unknown | any; // any
            </code></pre>
          </section>
        </section>
        </section>
      </div>
    </div>

    <script src="../../dist/reveal.js"></script>
    <script src="../../plugin/notes/notes.js"></script>
    <script src="../../plugin/markdown/markdown.js"></script>
    <script src="../../plugin/highlight/highlight.js"></script>
    <script>
      // More info about initialization & config:
      // - https://revealjs.com/initialization/
      // - https://revealjs.com/config/
      Reveal.initialize({
        hash: true,

        // Learn about plugins: https://revealjs.com/plugins/
        plugins: [RevealMarkdown, RevealHighlight, RevealNotes],
      });
    </script>
  </body>
</html>
