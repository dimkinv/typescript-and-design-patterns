<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <link rel="stylesheet" href="../../dist/zenburn.css" />

    <title>reveal.js</title>

    <link rel="stylesheet" href="../../dist/reset.css" />
    <link rel="stylesheet" href="../../dist/reveal.css" />
    <link rel="stylesheet" href="../../dist/theme/black.css" />

    <!-- Theme used for syntax highlighted code -->
    <link rel="stylesheet" href="../../plugin/highlight/monokai.css" />
  </head>
  
  <body>
    <div class="reveal">
      <div class="slides">
        <section>
          <h2>Generics</h2>
          <p style="font-style:italic">"Components that are capable of working on the data of today as well as the
              data of tomorrow will give you the most flexible capabilities for building up large software
              systems"</p>
      </section>
      <section>
          <h3>Let's implement a map</h3>
          <pre><code class="language-typescript">
interface Map {
  get(key: string): Object;
  set(key: string, value: Object): void;
}
          </code></pre>
          <p class="fragment">What's the problem here?</p>
      </section>
      <section>
          <h2>Generics! 🙌</h2>
          <pre><code class="language-typescript">
interface Map&lt;T> {
  get(key: string): T;
  set(key: string, value: T): void;
}
      </code></pre>
      </section>
      <section>
          <h2>top level vs. function generics</h2>
          <pre><code class="language-typescript">
interface Map {
  get&lt;T>(key: string): T;
  set&lt;T>(key: string, value: T): void;
}
          </code></pre>
      </section>
      <section>
          <h2>Another example</h2>
          <pre><code class="language-typescript">class Engine&lt;T>{
  constructor(private runnable: T){}
  run(){
    this.runnable.run();
  }
}</code></pre>
          <div class="fragment">
              <p>Would it work?</p>
              <p>What is the type of T?</p>
          </div>
      </section>
      <section>
          <h2>Generic constrains 💪</h2>
          <pre><code class="language-typescript" data-trim="" data-noescape="">
          interface Runnable {
              run(): void;
          }
          class Engine&lt;T extends Runnable>{
              constructor(private runnable: T) { }
              run() {
                  this.runnable.run();
              }
          }
          </code></pre>
      </section>
      <section>
          <pre><code class="language-typescript">function fetchProperty&lt;T>(object: T, propertyName: string){
  return object[propertyName];
}</code></pre>
          <div>
              <p>Would it work?</p>
              <p>What is the type of T?</p>
          </div>
          <div class="fragment">
              <pre><code class="language-typescript">function fetchProperty&lt;T, PropName extends keyof T>(object: T, propertyName: PropName){
  return object[propertyName];
}</code></pre>
              <p>And now? 💪</p>
          </div>
      </section>
      <section>
          <pre><code class="language-typescript">function animalFactory&lt;T>(Animal: T,){
  return new Animal();
}</code></pre>
          <p>Ok, this deffinitely must work, right?</p>
          <img class="fragment" height="100" style="position: absolute; top:-130px;right:-100px"
              src="../../assets/error1.png" />
          <div class="fragment">
              <pre><code class="language-typescript">function animalFactory&lt;T>(Animal: { new(): T }) {
  return new Animal();
}</code></pre>
              <p>Now it works with class types 💪</p>
          </div>
      </section>
      <section>
          <h2>Lets combine everything</h2>
          <pre><code class="language-typescript" data-noescape="" data-trim="">
          class Animal { }
          interface Runnable {
              run(): void;
          }
          class Cat extends Animal implements Runnable {
              run() { }
          }
          class Dog extends Animal implements Runnable {
              run() { }
          }
          function animalFactory&lt;T extends Animal>(Animal: { new(): T }) {
              return new Animal();
          }
          function startRunning&lt;T extends Runnable>(runnable: T) {
              runnable.run();
          }</code></pre>
      </section>
      <section>
          <h2>Decorators</h2>
          <p>Generally follows decoration pattern</p>
      </section>
      <section>
          <h2>Decoration Pattern</h2>
          <img height="400" src="../../assets/decoration-pattern.png" />
      </section>
      <section>
          <h2>Decoration Kurzgesagt</h2>
          <h4 style="font-style: italic;">(In a Nutshell)</h4>
          <ul>
              <li>Give execution of a component to another entity</li>
              <li>Another entity executes additional code together with original one</li>
          </ul>
      </section>
      <section>
          <h2>Activating Decorators</h2>
          <pre><code class="language-bash">
"experimentalDecorators": true,
"emitDecoratorMetadata": true, 
          </code></pre>
          <small>In tsconfig.json</small>
      </section>
      <section>
          <h2>Decorators in Typescript (Angular)</h2>
          <pre><code class="language-typescript">
@Injectable()
class UsefulService {
}

@Injectable()
class NeedsService {
  constructor(public service: UsefulService) {}
}
          </code></pre>
      </section>
      <section>
          <h2>Decorators in Typescript (Inversify)</h2>
          <pre><code  class="language-typescript">
@injectable()
class Ninja implements Warrior {
@inject(TYPES.Weapon) private _katana: Weapon;
@inject(TYPES.ThrowableWeapon) private _shuriken: ThrowableWeapon;
public fight() { return this._katana.hit(); }
public sneak() { return this._shuriken.throw(); }
}
          </code></pre>
      </section>
      <section>
          <h2>Decorators Types</h2>
          <h4>(In Typescript)</h4>
          <ul>
              <li>Class</li>
              <li>Property</li>
              <li>Accessor</li>
              <li>Method</li>
              <li>Patameter</li>
          </ul>
      </section>
      <section>
          <h3>Decorator vs. Decorator Factory</h3>
          <ul style="list-style: none;">
              <li>Decorator - creates direct decorator</li>
              <li>Factory - allows customization of decorators</li>
          </ul>
      </section>
      <section>
          <h2>Decorator Factory Example</h2>
          <pre><code class="language-typescript">
function color(value: string) {
// this is the decorator factory, it sets up
// the returned decorator function
  return function (target) {
    // this is the decorator
    // do something with 'target' and 'value'...
  };
}                    
          </code></pre>
          <small>from: <a
                  href="https://www.typescriptlang.org/docs/handbook/decorators.html">https://www.typescriptlang.org/docs/handbook/decorators.htm</a></small>
      </section>
      <section>
          <h2>Class Decorators (implementation)</h2>
          <pre><code class="language-typescript">
function ConstructorPerformance(Constructor: { new(...args: any[]): any }) {
  return class extends Constructor {
    constructor(...args: any[]) {
        const start = new Date();
        super(args);
        const end = new Date();
        console.log(`took ${end.getTime() - start.getTime()}ms to finish construction`);
    }
  }
}
          </code></pre>
      </section>
      <section>
          <h2>Class Decorators (Usage)</h2>
          <pre><code class="language-typescript">
@ConstructorPerformance
class Test {
  constructor(){
    let result = 1
    for (let index = 1; index < 10000; index++) {
        result *= index;
    }
  }
}
const test = new Test();
          </code></pre>
          <pre><code class="language-bash">
took 12ms to finish construction
</code></pre>
      </section>
      <section>
          <h2>Method Decorator (implementation)</h2>
          <pre><code class="language-typescript">
function ExceptionWrapper(target: any, propertyKey: string, descriptor: TypedPropertyDescriptor<(...args: any[]) => void>) {
  const originalFunction  = target[propertyKey];
  descriptor.value = (...args: any[]) => {
    try{
        originalFunction.apply(target, ...args);
    } catch(error){
        const typedError = error as Error
        console.log(`caught exception in wrapper, ${typedError.message}`);
    }
  }
}
          </code></pre>
      </section>
      <section>
          <h2>Method Decorator (usage)</h2>
          <pre><code class="language-typescript">
export class Test {
  @ExceptionWrapper
  throwException(someValue: string) {
    throw new Error(someValue);
  }
}


const t = new Test();
console.log(t.throwException('some string'));
          </code></pre>
      </section>
      <section>
        <p>So what else can we do with decorators?</p>
      </section>
      <section>
          <h2>Reflection and Metadata</h2>
          <h4>Let's look at the code</h4>
          <pre><code>
__decorate([
ExceptionWrapper,
__metadata("design:type", Function),
__metadata("design:paramtypes", [String]),
__metadata("design:returntype", void 0)
], Test.prototype, "throwException", null);
exports.Test = Test;
const t = new Test();
console.log(t.throwException('some string'));                    
          </code></pre>
          <small>Insufficient reflection</small>
      </section>
      <section>
          <h2>reflect-metadta to the rescue</h2>
          <ul>
              <li><a
                      href="https://www.npmjs.com/package/reflect-metadata">https://www.npmjs.com/package/reflect-metadata</a>
              </li>
              <li>~4M weekly downloads</li>
              <li><a href="https://rbuckton.github.io/reflect-metadata/">Detailed Proposal</a></li>
          </ul>
      </section>
      <section>
          <h2>Reflection with reflect-metadata</h2>
          <pre><code>
import 'reflect-metadata';
function ConstructorPerformance(Constructor: { new(...args: any[]): any }) {
  const start = new Date();
  const metadataKeys = Reflect.getOwnMetadataKeys(Constructor); // ['design:paramtypes']
  const metadataPatamtypes = Reflect.getMetadata('design:paramtypes', Constructor);
  console.log(metadataPatamtypes.map((param:any) => param.name)); // [ 'String', 'Boolean' ]
  return class extends Constructor {
    constructor(...args: any[]) {
        const start = new Date();
        super(args);
        const end = new Date();
        console.log(`took ${end.getTime() - start.getTime()}ms to finish construction`);
    }
  }
}
          </code></pre>
      </section>
      <section>
          <h2>Wait... What about javascript?</h2>
          <p>Javascript decorators are at <a href="https://github.com/tc39/proposal-decorators">stage3</a> </p>
          <p>Which means: The solution is complete and no further work is possible without implementation experience, significant usage and external feedback.</p>
      </section>
      <section>
          <h2>DIY (decorators)</h2>
          <p>Create an autologger decorator <br/>(method decorator factory),<br/> should log the following:</p>
          <ul>
              <li>number of parameters received</li>
              <li>list paramerts</li>
              <li>return value of the function</li>
          </ul>
          <pre><code class="text-language" data-trim data-noescape>
            function was called with 2 parameters
            parameters: 1, 3
            function result was: 4
          </code></pre>
      </section>
      <section>
        <section id="fragments">
          <p>what are the 8 types of javascript?</p>
          <p class="fragment">undefined, null, boolean, number, bigint, string, symbol, and object.</p>
        </section>
        <section data-background="#007acc">
          <h4>
          Typescript Basics++
          </h4>
        </section>
      </section>
        <section>
          <p>number 1,2,3</p>
          <p>string 'Hi</p>
          <p>boolean true false</p>
          <p>objects {age:30}</p>
          <p>Array [1,2,3]</p>
        </section>
        <section>
          <section>
            Type Compatibility and Duck typing
          </section>
          <section>
            <p>Type Compatibility</p>
          </section>
          <section id="fragments">
            <p>The basic rule for TypeScript’s structural type system is that x is compatible with y if y has at least the same members as x</p>
          </section>
          <section  id="fragments" data-background-color="white" data-background-iframe="https://www.typescriptlang.org/play?strictPropertyInitialization=false#code/PTAEFEA8EMFsAcA2BTUBGUBaUAVAnvKgMID2C0ALgJYBGViVFeoAUFQHYXIBOAZtAGNUABR4BnEu2iIAku14kMAbxag1oKbGQAuUGIrcOAcwA0q9dCM6NAV1g0eZgL4s2nHvyGhR3CVNnyJFBc7AAmyKHK5mqa1vqG7KbRoJbW7HYO3GbqKaGh3MhiYrrxxiwuLLw27ALUkqDwCRRyChgAFBwKuj5+0i2KAJQqOQKSEigAdIgkRh2BAwDc5a5VNXXsDU39UMhhEe2dJN3ikn2BwbvhkUPJo+zjyFMzcwqLyyx3+qCHaMe+pwEFBc9pFQABeUDDdSxXQAIgAgmJoLxYdkLFZdABmTFotTQPIFIpwgDWlAAXuxkIg-KAABwAJlARioADdKNA8FRYLDlp8KN9AvS-r1AYpwZDkjDQAikSjcSkMaBsc5XCBQAB3Eg2RChUAUAAWlA1JG4xIA-Kw1Y0OM1zpBLvsXiR6QMWGr9SR1SkaFr+QbKBa3WBrZx+mgnWhXaqwFA4EhUIzsPhCKBSORqHQGExWG4uHxBCITv5+oyoWoqKESgYyjkpaVEvLUrp0vZHO8bR4C6AAPLsRB4GS6svfSt6auJdvufNeIjQbj9CU5CtVhJJEaSeDQdh4ABycDi47X6l2zMpyYPq-lsBI4UQAE1kHOV8ZWBVVrUqPUQ7aFIyncKARLUAAB8ez7AdQhudd7hISZplmQ43gqPkGiLM4um8NDRUZCFh2XaU0FRSV9zhRFkSInImyVTFeTGflJH7QddF7RjdVw5J8NhekiJcFCBDnBd2KXUdYUxCj1DuTdtz3LQ4QAIQAWQAdXEtQTw4ZBzzhdSzwIZBVNAa9bwfJ9pXpAAGCzYVfaNjW1XV-X5TVTUDK0tkFNpCH+Yt5iDTYbRLNoGIgqN3U9b1fT1Q0KDNPzv0C-j5182zYwQFAlSwUAPS9CgSD0WCWVQRgLSYFMjGgGxuFCMRMoAESoMQBEMWAOEoF8AFV2E-e4c1KwtvOkWr2XFJRQnZACfN-UAnFAAAySE+t0AByLyRUwQ5MCqRBEEwMaKGgJaZpAyE9ugZjwMHGb5qUPU9OWitMGCw6lkqaoPy-dyFExUB-0wgbECG-aoIksZYMeeCnSQ2zNXsqKjWc81LWDT6SExNpRvG1bAMCExbsIOEsf8dbAk27UdtO2EnFdNyAsCNGMf27RgsHXHFulB7gsp0KwGyiKbD9aLYpp0MPIZs7Ev6Vm7ulQnpGJhRSe23b2S5uKUfpdHTu0CWcbx6xYQ58DVdstNN1XPVNVAd91jEFgUH5SAMAhNoztsVtuAGcEAD5QHMpZ7dAPAnZ+mhmwyRw9GfRJPbBH2-ehrUdThpyTURlgg-FR2FiRrLwugH1+eToWwEd8Ug+z1w7eQB2cJ+12W0yXHQjNbR61MNQBBbsdVxjuP-erwPa7aUO3cbyPu+MXvfZesKvXzyL2E9YvB8z+kK78goKEqjY+ttquHe+52p-RjQSOleEGCEayqf7-k8EPn7j5uqUEUv-Tcemfj1jhABlR8KAoCga+bw1QwyTo5Y0Lkc6QAfvfCus8+YCwDH5e+mdMTrz8kpaKiDQC7DsGIQMLA8GwFAD-faW8apQgAEqPlCHgNESloCMGMCqYhqZYImkXKAGhoQ0RyUQDYZAaIADiBRdgqgDvoSgNgxDBzIdIsQEwaH4jwEsNUUiKHB1INMbgExRHIF2BgtUWCjTz0LgIRA0AiiFEIRYqxNV4RdVgNILhvADEUDDu7JYHc6LcBsLUE0bQ6yHlxi2AAYu4zxmRPZKBcMhSxRRSFUDJKgKEbjq5RJ4N40AfI-EBO4EEuwESMmjx4DEuJrgA6u0cVyaQt9x4-2ScgNRYBoDijENnNU3YADSfkaoQmgJ0sAPS-LyOoAIQyyB3Y1S3LqXJ-jcq+FAKEPKi9+TIjcbUHJZBNwZnoIwPAQA" data-background-interactive>
          </section>
          <section>
            <p>Duck typing</p>
          </section>
          <section  id="fragments" data-background-color="white" data-background-iframe="https://www.typescriptlang.org/play?#code/PTAEFEA8EMFsAcA2BTUBGUAoTBLAdgC7IBOAZtAMaoCCoA3pqE6HnMgFygDOBx+A5gBpGzaPw4sArrABGJTAF9chEuSqgAQvRFNWsCTz54hO0GIl5pc4ouwUA9nh6gZ7LQF5tzFm04Aiai5oUj9hb3NOAGZI20wQUAB3e0lEABNQAgALaAJE+2IAawB+OLAHJ1zoTlpPGQBubFKIGAQUUAAmLGUiMkpUAGEvZnhie3g0TkMBMOHR+HbJ3mnTEbHIxaMTb1X4ABYN5e25gFYD4xmmHYA2M63ZsYB2W4vQHYAOZ5W5gE5Po7G0AAGT5KfA9NSoAAiQ0ucwm3CW5y+YwWCM2Lx26zRh3uez+uNO2KR-3gNyJd1hj3xlPgH3JGJ+1NecOB9Ni5WcFE4g08DBJ8IA5Ds0AKGSjOEK5u1Rcj4FjJWsZST9qAFXslQSJTtjhqaWS1Vddcyqaqdg8je8tXM3hbGaafraAay1UCZUpMKRJHgKAQcI5mWCAPIyABWAAp7KHOJCAJR0LDeDn2FAAOkQ9n4EdDMdi8SSKXSWRyeUKJXiIyDobDFBjQA" data-background-interactive>
          </section>
        </section>
        <section>
          <section>
            <h4>Tupels</h4>
          </section>
          <section>
            <p>A tuple type is another sort of Array type that knows exactly how many elements it contains, and exactly which types it contains at specific positions.</p>
            <pre><code data-trim data-noescape>
              const role:[string, number]
              </code></pre>
          </section>
					<section  id="fragments" data-background-color="white" data-background-iframe="https://www.typescriptlang.org/play?#code/PTCMDoAJIdwCwIYBdYHsCuAbAJpJBPABwFMBnAYwCcBLQlagOwDNjKB+SAKBEk2JQC2+AJLNUkALyQA2gHIAgqQRNZAGgDM6gLoBuTt2AAmKAd79IQ0U1QAuGaSQ0GAc1WQG6AQCNWWyTIUlFQ1tfR51KBhqTEw8OGpSNEoAaw5TSzFpAAY-KQAiABEEBgZ8PPSRTNBcyELi0vLTABZI6NikeMSYVBS2CqtUcEJ0UjgAClAsrIBKPVMAVlaYuISk1K4eDOt-aS0w4EgANiX2zrW0zcrtqTlFZTVNN0mc-cgAdhO45HONg-JUBgOGRCAByCAExDcCGcxBqW1Qc3SPWIKxciXwGEg5GKkGw4iiHUgCDw6EIfBsrwgJLJZCxOMQADcUag6NQAQhYoRKCzWEhqGRXgQSJAAKLUDqsQzYADylHUuBuHm8rDcSp8lFVnnVbF0pn+gJQ-x62FIoB26imbiaUz2PH1QKNlBNhnNlsg1qybnmNr0doBQOkAA9QG58NV-I6TaA9f6UEHDKGE5AAF6GGqR0iGV7GSAAFVJfES2IYRMwpHEjJRlDIKGIfAhDCQpDc8Go5DgkEreHEPiJJYQlEoCHwwCQBZRQuI4FMCGnPEnkAAyo5GM4QVrWAAhVCoPjFRI3BxOVzuDcayDgS9eHd7hi7XV+g1EuzL4-r5WUbe74j7nZ5bqUDgeRuOobiOOgkKQEwHKkJB4GQdBZZwZQEG6qYXhzgcC6vquX63qQ77qjsR6rm4l7gNe37FLsmofg+fyxpAXgviuLh4T+gKEawf4AUBqjwW4iGwWBKEITByEQSBaF2pheBECi7H7jhLhcZQOzkZRt40ZAJEuLR6r0VijHkHYimAspa5njsAlQeJImSbZSH2ZB-49HxkDaHMPDEIG4I0hSPBMOgDDkHyAKQNWCDYJu6BIEgAKiMMSBjORA7OKQdjSLpJ5qiqF5XjeHH3tMkAAN6mNA9pxgw4KQUylCkGyDBkZejBJTUaWkL6BzQDw5GmAAvvs3RYLgHTfABqSmJF0WxfFDCJbFYyyDVEJqJASbwdMw0YDgXwoJNfQ8DNMVxQlDBJctq3EOtm2ifx914I9QnENtBgjXt40HT0U3HT+s1nQtF1LSttW3W9IAfWNiDfb003-ad82LcloNrRDwC5mcqyIAw2D4LAcDECWGLoLAxQoPFeAIMkKLEgyA7UAgXh8KeH6QKgTBEpQzieETTawOKHbEtWQKEAOtVIHlxS4CT7jEMQuDEgIjDUAInis0RHOQHWxANk2bjobFkCy3iDCAJgEB3k92kCMI4qDYOg5AorbrAQtgjOS5A9M0EzhbTvsEQRf9AKYPggryZAACyVziFIM0h-jWWsTlZ6GXwggx3Y0cDDsgT3CBnmmFD+3nP0mQ5P4shFCU+CyFw+wtJAAAKCCkI1LhEtSLOt53IsoGLQ4CNbxJBSFYUMAFDFPniy7oEwnNSGMpgAJCpdzGUyOR10b9l2kr6Mu3YAAwgghDihy1DJsQdiaRxtoHNMdgMqg1AKgAfGVK88HiOljvP-U8CGqYGef8mBjBettb+qBZ7zzGHkFgxBgK1CYNQJB8DUBoKCgIYCW09BAA" data-background-interactive>
          </section>
            <section id="fragments">
            <h4>Summary</h4>
            <p class="fragment"> Tuples are not inferred by typescript they have to be declared.</p>
            <p class="fragment">Even when a tuple is declared (with fixed length) it is still possible to push data to it.</p>
            <p class="fragment">A tuple can have an optional value at the end</p>
            <p class="fragment">A tuple can have a rest param at any place</p>
            <p class="fragment">The last can be used in order to pass deferent types to one function as one parameter</p>
          </section>
        </section>
        <section>
          <section>
            <h4>Enums</h4>
          </section>
          <section id="fragments">
            <p>Enums are one of the few features TypeScript has which is not a type-level extension of JavaScript.</p>
            <p class="fragment">Enums allow a developer to define a set of named constants. Using enums can make it easier to document intent, or create a set of distinct cases. TypeScript provides both numeric and string-based enums.</p>
          </section>
          <section  id="fragments" data-background-color="white" data-background-iframe="https://www.typescriptlang.org/play?#code/PTAEFMA8EMFsAcA25QEYBcoBQJQGMB7AOwGcAXUAQQBEBZASQDlQBeUABhzENIoCUAojQD6AeUYAZAJqs0XfMXJUAqgBUAEqL6yATAG4s8nkviyA3vNBXQROOEwAiSiWgAzBwBpL16AHN7oADMgV641qAATgTImDQMjPIAvoa4AO4AloiIoGQAFtAUqQQRANYA-Ni48AB0UciyAKwpYFBwSCg6mIwArrDgEel4EES9JPLgI7CgfNEoFmHWcUyhYOGCIuLSK+EqGlpJzQq8oKZs86vWtn2Ozm6e3lZ+AcHb4XUBM8jVSwm4yWmZbJ5AqgIqlCryGrvRqGQ6tBD1QKYADKZAGRF8w1G40m01moHOOx+rCcdCY9wWVnW1DEkhkbAc1Np0gpFyslDUmj4DI5ez4DgOh2MFFOBIeNjsoHQDmgLncrx8-kwL3F70wn3A3zJvzAyXkGSyOXyhWK5UqYCh+LYTSqtStoActFEAGEANLCPiiCQCAW26E87W+i12+psDVa+JwmAIlAAFnQ8nSJCNIImvVAADdoIh0gATCG4NNTDViylUbWNBVUoQ0zZSKu7LmCwvR9qgBoJ3BJlMUIuZ7N5gstXElwnhYkB+KsnZMusN3lNv5Rtr1ABsmETyeBvdxWZz+fNWOL+LHiwr1obs7pslQ7HY885WlkTkf-Ob3EUIvM4quKGlsruBsnmVEJVVmdVZgjJh31BQEe1BU0hxOEMUGtSEUOfJ03Q9L0fXQ-0HR+INkII8MfiAA" data-background-interactive>
          </section>
          <section id="fragments">
            <h4>Summary</h4>
            <p class="fragment"> Numeric enums have auto-incrementing behavior</p>
            <p class="fragment">string enums don’t have auto-incrementing behavior</p>
            <p class="fragment">String enums allow you to give a meaningful and readable value when your code runs</p>
          </section>
        </section>
        <section>
          <section>
            <h4>Union Types</h4>
          </section>
          <section id="fragments">
            <p class="fragment">A union type is a type formed from two or more other types, representing values that may be any one of those types.</p>
            <p class="fragment">We refer to each of these types as the union’s members.</p>
          </section>
          <section  id="fragments" data-background-color="white" data-background-iframe="https://www.typescriptlang.org/play?#code/PTCmA8EMFsAcBtQAICMAuAUCJAzArgHYDGALgJYD2BSRF0ARmQaABROx4npIF4OgAnADRJ2nAExoefeoICUAbyzAkq1QNAk8A6mK5IA1KIIcS45UgC+ygO4U88ACZISAC0gkkdgQGsA-Ba0BADOnrQMTKDOALw0dIzMLChC4nIYyhAwCMiSFvjE5FRxEYl63KECTADmInqSSBXVihZqSBpaOsamKIZdEhbWIHYOzm4eXhS+AdhBocUJUUix4QssAEQAgsGQOGsiawBykJMAnmtpGVBwiEgAzJjYw04u7p7e-nmEpJTUK5FsJk45RIlQIVQAPtJ+MI+mYpI0wZDeNDmthWu1tLpAfojHUBulsJlrsgACxST4FH7zf5leEg6pImSCWrY+oIiFQ2QCVEqVpkHAsEgnWCgCg4WE9aKxADkyK50qQADJFS5haLxXUljK5YIFTzWgaMZ0yr08Wi1INeWojVjugA6EgUADK9LBLDkptZDudrqq+KG9meYzekw+Myocz+zBi1MSyVSgQjYXikRjUdYm22u32R1O5wJKiJ2SQAFZyQGRi9xu9pip8t8irBQSQAJKONiOKQ6gRISHsj1Kc2zCiIO3wChVDvegCqsBFAgAwpBgqw5HIANz4ixFm4ANnLwCeo1eEymFIb1CbTFb7bInc5gl7DV9A5aonFgrVYtEMSlSDW7LnEgg5Wqo2AttQbhkMESD0AIkDEK4tTONBSDfkKIpINK7LSm+qjDqO46TneM5zoIS4ru6G5vpYSCgPAK7AXhSDYAAEoIoDIaIMHoWqWHdrh5r4RGI6gGOE4dtR5qWlY6QYNegg4JARDIAAQmQAjOEoqg4PAJzulIABuFB3puqjwJAJwAKJVFUwQGUgxmmRg1hIPJBAkIpynIAAYtBrhMaowQ2GQ0AOU5jhmUgFnWbZ9lyEZJmRS56QYb5-kAPICOpmlLEgfnBAFkI5clGCOKARAWRouBfIU1BVJoTrQJA8DwAACpoDkFa4WUlRgbmIJ4IqeLEDUkE1LXtZ1UmHmQrVViGUxudgw1jpZNl2e6m4WK4FA2EgkD0PYnjBrWSCrcFoVbXJN23Xdt1AA" data-background-interactive>
          </section>
          <section id="fragments">
            <h4>Summary</h4>
            <p class="fragment">A union type is a type formed from two or more other types, representing values that may be any one of those types.</p>
            <p class="fragment">TypeScript can deduce a more specific type for a value based on the structure of the code.</p>
            <p class="fragment">this pattern is called "Narrowing".</p>
            <p class="fragment">If there is a realationship between input and output, use function overloading.</p>
          </section>
        </section>
        <section>
          <section>
            <h4> Literal Types</h4>
          </section>
          <section id="fragments">
            <p class="fragment">In addition to the general types string and number, we can refer to specific strings and numbers in type positions.</p>
            <p class="fragment">By themselves, literal types aren’t very valuable</p>
            <p class="fragment">But by combining literals into unions, you can express a much more useful concept - for example, functions that only accept a certain set of known values</p>
          </section>
          <section  id="fragments" data-background-color="white" data-background-iframe="https://www.typescriptlang.org/play?#code/PTAEFMA8EMFsAcA25QEYBcAoEoDuALaAF1AEsBnUI-FIgT3hQHsAzUAIwH5RNRkT2oALygA5O1EBuTNjBQ4SFACYsOAsTKVqtBszbQANFVDQAdgBNQpgK6xumAMZNT5EtGFjoUx89fGRRABO1uDSTi4kNrAeqNKyEDAIyKAqmCzWpg5EpM6g8IGkpkQAKlBEABTk6KCuBaYA5kbQiKT1prDgRdUARMgsRN2gAD6g3QX1+APDow6dROCB3QCUoADevKA4AHQ7mAC+8bikiIhUhCS4TIEA1pzx+YUlZeXdABLgJ0xGl4GI5t1GXrgfrLOI4fBMXAmdhMawkajEO44B5FUqQCrdADionM0DoRlgxHAAJmc0CxKWYLkiUUoAAzKAALSgOiw0AOMzspiwdiFWg0cgoI7UKzORkteaBZpUXRVGSPBYsaCzUAAeXg2V8aw2R3M1GqUXYC2kB3SmU1pi5phYrWs5PKkGq6otlBG3WgcKYy21oE2YB2W32h2OpwRFyut3i4Rt9Tt4HKqzwpD1+GqqAADOnQHtKTJwZDobD4eckWBo7b7e7PaC82AIVDoDC4WdEVHnDG4y8PURucRSA4a-F5EkUAAWarxeiMcgOAoa9mcpwj+Ys2GBKhlPA0S2s6ygayCshENIZLI5S1L3mmeOFeBwjA1IKFerTQ0LIy3uEqR91F8jN+BEY5LkNYiBEAAws4ABuCzkOe1SiNA5CMgBojTIhyHzOiogrOsvq+qQLDlFO4CsGQph3kQqDCCIoioaAABkDEyowZGfkQSg0WI9FMaAwGgRB0GweeXEYShthGoEOF4fhsnkkQdqWgA1Ox1FKaAKkUV+Gy+gccngApgSWqpWw9gAyk+DTlCs6nsUoplMBZv7WUGwYnC24Y3KWXI8ny5SoEYShGGJb44bWCQKMkACsE78KAsB0AAkuY1QAAYACSrABeyMsmqVUkc7lhngEbeQlyUeKIqBKHSuXmKItb1oWzZhmVSWWLRzgGZc1DkuAdWiEAA" data-background-interactive>
          </section>
            <section id="fragments">
            <h4>Summary</h4>
            <p class="fragment"> Literal Types are inferred by TS when using const</p>
            <p class="fragment"> They are valuable when using in Union Types</p>
            <p class="fragment"> They are also valuable in Discriminating Unions which we will see soon</p>
          </section>
        </section>
        <section>
          <section>
            <h4>Union Types vs Enums</h4>
          </section>
          <section  id="fragments" data-background-color="white" data-background-iframe="https://www.typescriptlang.org/play?#code/PTAEEYDpQdwQwBYBdYHsCuAbAJqBcAHAgUwDtQBLcgKzgDc4BnAYwCcKCkB+AKCQE8SoAGrEEFZpmIAVQcQCqpCqnIBeUAHIAyvOEbQAH01aAogBEAggDl9RjdIBK8gMIBpDQG4eZdAFsRYhJSsiQmpH6gAN48oKA6wgA0MXHm1kmxji6uSQC+PPkgoABMkDyFAJJmJnhMoHDoSKjMqL4EUkjEPABm6KTMSMrkXaio4KAAFL78znCs4ABcAeKSMnKKgwmgUzOsRYuiy8FyYX4AlNGxsRRdk9OzY6qPxqk253mXlDfbs0Wgj+oHIKrULhXyQUyWKxvHh5MrAADMpRAMAwOFASHwKBRrAA1rxCs1SIwUMx7qB9oEViFiCd-OoigAGLxwuCkXAYuDcOGgQnEnk-clLIHU9YqP6aDrEzwFMAAFlAjFQmAagy4XHm3lBQqpci0SHYpAA5rSosl4uLtLoNOkUpCLRDrNbkpk3BaXe5cvken0BmLhqhfrcdgttUcSHqDcbQedklcvnc5n8noCdeH9VQo35wS9obDCgBWaAwCgY0C9QaMUD8DD88joRjELaoViNgQkSsc8jEyOMbkorDszFoXH4sBtxvOADyABlJw4tBaHOZbJoAELT+QmFcMwygADaAF1mYVWYPOcO8dyfP4p7P56bCrEl2ZF8uko-QOvNxav1v32BYgsBwHAsABNcVD25PMwAANiLVEzyxZs8VAblhlYCZeRQcdKHIFMwxpaMHwAnkVEVKRIEwVBDXGcdTi8QpoNAScACNqGIfpIBxYh+EYcZ8OBQizkgdCTDgZgEHGcZuP4U4-gAPmIy5eSVYhKOo8YNBkzRNhk+ioNOGU6jZdFMVHUB0MwsjsLkXDQ0E0VSDk6IPxUiiqJouiGLAJjWPYziZL4gSRSUFRThE5sxIkqS9IUpTYjctSPM07TrVAPTvNAHJTiAA" data-background-interactive>
          </section>
          <!-- <section>
            <h1>  narrowing example - redux </h1>
          </section> -->
          <section id="fragments">
            <h4>Summary</h4>
            <p class="fragment">If you are looking to optimize your code and reduce the bundle size at the moment of compiling into JavaScript - union types</p>
            <p class="fragment">If you will be needed to run iterations over a set of values, enums are the way to go</p>
            <p class="fragment">If you have only 2 options, I think unions are better</p>
            <p class="fragment">If you have more than 2-3 options, Enums are better</p>
            <p class="fragment">If you don't have a very good reason not to, use string Enums</p>
          </section>
        </section>
        <section>
          <section>
            <h4>Type Guards and Narrowing</h4>
          </section>
          <section id="fragments">
            <p>what is narrowing?</p>
            <p class="fragment">TypeScript follows possible paths of execution that our programs can take to analyze the most specific possible type of a value at a given position. It looks at these special checks (called type guards) and assignments, and the process of refining types to more specific types than declared is called narrowing</p>
          </section>
          <section id="fragments">
            <p>1. The instanceof keyword</p>
            <p class="fragment">2. The typeof keyword</p>
            <p class="fragment">3. The in keyword</p>
            <p class="fragment">4. Equality narrowing type guard</p>
            <p class="fragment">5. Custom type guard with predicate</p>
          </section>
          <section  id="fragments" data-background-color="white" data-background-iframe="https://www.typescriptlang.org/play?#code/PTAEEYDpQFQCwKagJYDsDOAXAhqgxggPYBmomAngA5IDmArtgE4AmAUHgDbbrqgCy5AMJceoAN6tQU0HkIZMjOnkyFGACkp0ARh2R5QqbAFsEALlBZGaGgBpQmnXtDYaZg3SNaEjAJRiAvqyB7HJYoCagALwGCADu-EIi6GoA5ACC6NjEKXYAzLk+ANysrCCgAOpw2JigsYR0HMygXmSIoPU1mpgA-KzEdPiYyHKgxISEoGom5gMA1qiEsag+4qzIxFNIaFi4BCQJwtzofpLSZ7IYhBwIkByENKnbOPhEpAKHPCk+p2dSZXUNJqYKo1OqMWbdUA-X5lC7oK43O4PcI3QwmOwmSAuBDfM6BM4IDjoJASX7SOEI273VILGpPXavA5JL7Qs7-eqNVrVWqqCFQsl-MAU65Uh6YtEIDE3bG46SBYJlABMoEg8CQFGo+w1tAYLD6A2Uw1QoAAypg6MwEKhMABJZhqAAe5ks1lAAB93J5vDYVqTpOtJtr9g6otEUi7UDQvqsBTJQpSkakzRarZgvsVY+y6MhOcDuWCIazpGUHZA0JwU+gi4KedncyCeeDepmwKW0JaHQB5YjQ-H+0hqIOkEORUegFKoDxeRjRv1k4WI6kpO3p6ugLP1-O85sCkuQFRmqyRtSyqTykplXLQNUoY3a0D0JhsNCYbzEbAEUAAEXuMekEudBRrBsaEtCYWZAKPGggjWa03w-JAABkjT-KQAIsIDIxAs5GEIJhIOsGCX3gz9BEWVCDGMNwI1saEjHGAjIxg-VBhQ3BkCMbAOD4bBZgQAA5QhkGJNR2M4jhzB-Gh3VAZCRg9MjYhOM51lSMDwRSW9nFQDiuOUgUF1FVJyhIUg6mIbJT1APspEJYkUA2FJcKYTS0G03SOH0+d4xFRMUgAJTwxhgsYABCUKWTxaE7K2Rz6MIVzjTEvS51+Qy-PiwhwsiuVmLKAAWaAAFEAEcGF0ChKOCxZXXvR89X6ViRgQB1jEoa5HUY6SPUnL1GDscgupkrRxmuXBfVOANHVDaJyAmtkwHKJA8FwAxyJWjgOG08hxxozSTGBQgmhGFIHU01Rx3IFJIGhaFSxUABVShqEYQRuAQE8M2LMBNkO5gVkPax90IJ6XrekSfC6koznIYHEMWbxwY+ooyWhMpfrgI6Acwmg4YR173pPKHTn8UAYoo9LqQdFHYykNGfsoJgqNfXxQCdDCoJk3rp2h8kfMXB45sKWm6YWyZGcYZnvBWQaOddD0RoRXBefPUpgAAVmgQQ6CwQgjDIKgdSfWpkGBexGAQZg9GqBBWHvAAxYS4CicQLFiDjzBPKIAD5QAANyEpp-GKe8ACFkBYF2xFGDhZa9yJfYD5Ag+KRrDRGVxMBNcSOAABQQTAidAR30Gdj1w5YVK4RqSXUGYPWXZ44FIFr+ujBPaFVNbhvfYABkgdWvN+C3zUYY0xHQd2jE9nwE-ESmHnDKevn8GzrOhEe6DH8RiFjme57EBfUl3q6fFXvKwFDwgzY2okyAmJeOM03AmhSE-n4ttb4kIWZsFh1hridALi7TO2cuJ5wLp9EIlxfLUmoJgb4R9hIlzgBoAuPhvhrAHMgp2aCEHzXsAXSAk8OJQNJuTP08DIAnzIWrWAbR7yUAtlbFar5CF0l4Cgk2m1wi8SQDAQ2Jo8BWEoDXS2Sh1QMMNvfYuTtbxYAQNgY6pBN5j1dAAKx1jUbAzRRqKONH7LidAbgsXTsaHBpc8HmC4eXCO-1zDwJQJwuRfpVHGjwc4ZxpcfDEKnqAUKY4BiWmIGgS2xRgjV2cMFF2ABtcMONwA5FAEEhAITUCWzsJk0AWT4lQUVEklJaSMnZJKbk6wuQkmZIALqpwNEMEYYxCCKkHEND0hTQn2LIE4uWkZUpuK6QE6I7T0nMHCdAsIISOAs0ti7JgjBqE5hZmoRpioiglCPpM6Z-0gA" data-background-interactive>
          </section>
          <section>
            <p>what is the problem with this?</p>
            <pre><code data-trim data-noescape>
              catch (e) {
                console.log((e as Error).message)
              }
            </code></pre>
          </section>
          <section>
            <p>Solutions</p>
            <pre><code data-trim data-noescape>
              catch (err) {
                if (err instanceof Error) {
                  console.log(err.message);
                } else {
                  console.log('Unexpected error', err);
                }
            </code></pre>
            <pre><code data-trim data-noescape>
              catch (err) {
                if ("message" in err) {
                  console.log(err.message);
                } else {
                  console.log('Unexpected error', err);
                }
            </code></pre>
          </section>
        </section>
          <section data-background="#007acc">
            <section>
              <h4>Type vs Interface</h4>
            </section>
            <section>
              <p>Interface</p>
              <aside class="notes"> 
                One of TypeScript’s core principles is that type checking focuses
                on the shape that values have. This is sometimes called “duck
                typing” or “structural subtyping”. In TypeScript, interfaces fill
                the role of naming these types, and are a powerful way of defining
                contracts within your code as well as contracts with code outside
                of your project.
              </aside>
            </section>
            <section>
              <p>1. Interfaces can be extended and implemented</p>
              <pre><code  class="hljs" data-trim data-line-numbers="|1-5|7-11|13|15-17|19-24">		
                interface Person {
                  name: string,
                  age: number
                  sayHello:() => void
                }
                
                class SomePerson implements Person {
                  name ='Asaf'
                  age = 32
                  sayHello () {console.log('Hello')}
                }
  
                const p = new SomePerson();
                
                interface Developer extends Person{
                  typescriptMaster: boolean
                }
                
                const me: Developer = {
                    name: 'Asaf',
                    age: 32,
                    typescriptMaster: true,
                    sayHello: () => console.log('Hello')
                }
          </code></pre>
            </section>
            <section>
              <p>2. Declaration merging</p>
              <aside class="notes"> 
                “declaration merging” means that the compiler merges two separate
                declarations declared with the same name into a single definition.
                This merged definition has the features of both of the original
                declarations. Any number of declarations can be merged; it’s not
                limited to just two declarations.
              </aside>
            </section>
            <section>
              <pre><code data-trim data-noescape>		
            interface Box {
              height: number;
              width: number;
              }
  
              interface Box {
              scale: number;
              }
  
              let box: Box = { height: 5, width: 6, scale: 10 };
          </code></pre>
            </section>
            <section>
              <p>Type alias</p>
              <aside class="notes"> 
                it’s common to want to use the same type more than once and refer
                to it by a single name. A type alias is exactly that - a name for
                any type. The syntax for a type alias is:
              </aside>
            </section>
            <section>
              <p>1. types can not be extended - types intersection</p>
              <pre><code data-trim data-noescape>		
            type Person = {
              name: string,
              age: number
            } &  { typescriptMaster: boolean }
            
            const me: Person = {
              name: 'Asaf',
              age: 32,
              typescriptMaster: true
            }
          </code></pre>
            </section>
            <section>
              <p>2. Union types</p>
              <p></p>
              <pre><code data-trim data-noescape>		
              type Person = {
                name: string,
                age: number
              } 
              
              type TypescriptMaster = { typescriptMaster: boolean }
  
              type Asaf = Person | TypescriptMaster 
              
              const me: Asaf = {
                name: 'Asaf',
                age: 32,
              }
  
              // or 
              const me: Asaf = {
                typescriptMaster: true;
              }
  
              // or
              const me: Asaf = {
                name: 'Asaf',
                age: 32,
                typescriptMaster: true;
              }
            </code></pre>
            <aside class="notes"> 
             We can not create an interface which is a union of other 2 interfaces or types
            </aside>
            </section>
            <section id="fragments">
              <h4>Summary</h4>
              <p class="fragment">Interface and types are interchangeable sometimes</p>
              <p class="fragment">Interfaces can be implemented and extended </p>
              <p class="fragment">Interfaces have Declaration merging</p>
              <p class="fragment">Types have types intersection which are close to interface extention</p>
              <p class="fragment">Types can be used with Unions, interfaces can't</p>
              <p class="fragment">Types can be used with Tuples, interfaces can't</p>
            </section>
          </section>
          <section data-background="#007acc">
            <section >
             <h4> type never </h4> 
             <aside class="notes">
              The never type represents the type of values that never occur. For
              instance, never is the return type for a function expression or an
              arrow function expression that always throws an exception or one
              that never returns. Variables also acquire the type never when
              narrowed by any type guards that can never be true. The never type
              is a subtype of, and assignable to, every type; however, no type
              is a subtype of, or assignable to, never (except never itself).
              Even any isn’t assignable to never.
             </aside>
            </section>
            <section>
              <pre><code data-trim data-noescape>		
          // Function returning never must not have a reachable end point
          function error(message: string): never {
            throw new Error(message);
          }
           
          // Inferred return type is never
          function fail() {
            return error("Something failed");
          }
           
          // Function returning never must not have a reachable end point
          function infiniteLoop(): never {
            while (true) {}
          }
        </code></pre>
            </section>
            <section>
              <h4> type unknown</h4>
              <aside class="notes"> 
                the unknown type is simmilar to the any type, however you can't
                assign a value of type unknown to another value with different
                type without type check (typeof) first.
  
                Anything is assignable to unknown, 
                but unknown isn’t assignable to anything but itself and any without a type assertion or a control flow based narrowing.
                Likewise, no operations are permitted on an unknown without first asserting or narrowing to a more specific type.
              </aside>
            </section>
            <section>
              <aside class="notes"> 
                Here's a list of assignment examples we saw before, this time using a variable typed as unknown:
              </aside>
              <pre><code data-trim data-noescape>		
                let value: unknown;
  
                value = true; // OK
                value = 42; // OK
                value = "Hello World"; // OK
                value = []; // OK
                value = {}; // OK
                value = Math.random; // OK
                value = null; // OK
                value = undefined; // OK
                value = new TypeError(); // OK
                value = Symbol("type"); // OK
      </code></pre>
            </section>
            <section>
              <aside class="notes"> 
                What happens though when we try to assign a value of type unknown to variables of other types?
              </aside>
              <pre><code data-trim data-noescape>	
              let value: unknown;
  
              let value1: unknown = value; // OK
              let value2: any = value; // OK
              let value3: boolean = value; // Error
              let value4: number = value; // Error
              let value5: string = value; // Error
              let value6: object = value; // Error
              let value7: any[] = value; // Error
              let value8: Function = value; // Error
              </code></pre>
            </section>
            <section>
              <aside class="notes"> 
                We can narrow the unknown type to a more specific type in different ways, including the typeof operator, 
                the instanceof operator, and custom type guard functions. All of these narrowing techniques contribute to TypeScript's control flow based type analysis.
  
                The following example illustrates how value has a more specific type within the two if statement branches:
              </aside>
              <pre><code data-trim data-noescape>	
                function stringifyForLogging(value: unknown): string {
                  if (typeof value === "string") {
                    return value
                  }
                  if (typeof value === "function") {
                    // Within this branch, `value` has type `Function`,
                    // so we can access the function's `name` property
                    const functionName = value.name || "(anonymous)";
                    return `[function ${functionName}]`;
                  }
                
                  if (value instanceof Date) {
                    // Within this branch, `value` has type `Date`,
                    // so we can call the `toISOString` method
                    return value.toISOString();
                  }
                
                  return String(value);
                }
              </code></pre>
            </section>
            <section>
              <p>If you want to force the compiler to trust you that a value of type unknown is of a given type, you can use a type assertion like this:</p>
              <pre><code data-trim data-noescape>	
                const value: unknown = "Hello World";
                const someString: string = value as string;
                const otherString = someString.toUpperCase(); // "HELLO WORLD"
              </code></pre>
              <p>This can easily lead to an error being thrown at runtime if you make a mistake and specify an incorrect type:</p>
              <pre><code data-trim data-noescape>	
                const value: unknown = 42;
                const someString: string = value as string;
                const otherString = someString.toUpperCase(); // BOOM
              </code></pre>
            </section>
            <section>
              <p>In a union type, unknown absorbs every type. This means that if any of the constituent types is unknown, the union type evaluates to unknown:</p>
              <pre><code data-trim data-noescape>	
                type UnionType1 = unknown | null; // unknown
                type UnionType2 = unknown | undefined; // unknown
                type UnionType3 = unknown | string; // unknown
                type UnionType4 = unknown | number[]; // unknown
  
                type UnionType5 = unknown | any; // any
              </code></pre>
            </section>
          </section>
          </section>
          <section>
            <section>
              <h4>Function overloads</h4>
            </section>
            <section>
              <p>
                TypeScript provides the concept of function overloading. You can have multiple functions with the same name but different parameter types and return type. However, the number of parameters should be the same.
              </p>
            </section>
            <section  id="fragments" data-background-color="white" data-background-iframe="https://www.typescriptlang.org/play?#code/PTAEFEA8EMFsAcA2BTUBGAXKAUNkoB3AC2gBdQBLAZ1FKNXgCcB7AIxVlHseQH5sAZgFcAdgGNSFZiNABzHslJoAFPGSMq0rFVKMKI2aAA+oHXoMBtALoBKbbv2GTZx9dABvbKEoDQy0gCeasy+ahrSoAC80aAA5C4GsTYeXt6gPKRCjDIABgASyIiIzAA0oAAk7mGaIgC+AIQ5ANyptaCFVKgUvsoAgoyM0AEAdNT9gwGq6jU2yZ5p6YpZMtXSw7DQ8MoicKiRAHyg+YXFZZU7sMgNOTYt3rWpdCwEoCLIL+ADzIzKsQCqO3YqFIzDkClISRaDzwYGIZEoNDowKCqBCpl0vFAYmgMgo5B4RQCoFYqGg6PMsn4YmkOnJaCi3nkyEUKgssV6VGgAliZViABEcSIArFbE1QPg2QUiqVQByufUeXEpadQAKREKFVYYYRmEJEAATWgkcgEb4Aa34+DMaGGIL+8DCAGFoJ1lLdcPg4eRqEbkWpQGizONMdjcfiTkSSaAcdGBkMqTTyEGBvSGUyWb8AOrfA2Q8VgWLKmXZxgG+ra016w10eGmxgW7XJxg2jZbN0Hdy1GwesBQOBIVAAJgwPdAAHkAG7qYrQQ1UCiyHaZHhUQSiCRSGTp0iDqbhET2Cl2cmOFrCcSSCLb3erERUQ+uWwPyxWO7agCSCA4yBEpDIm9MBclyyZA1wvADrz3GosFEM0RGYAgRGPWD4MQlJvG6PxAmCUJpgiaJIjiBJZCSdC0gyZYjiLM4qjwupGjuUA2g6LoenGIZRiodjJlvWYyO8CjslAW91k2bZdiiQ5jmlGiLiuRp3XuR4iGeV53ggL4fn+QEUFoUFt0hbBoU9Y0EV9WgUQDXwm0HTFsGpO8k10cZBwZMFmR3ZQ2TlbleTVIURXdUcvTMpELP9QNdFsnAHNpMxXLTcFd1iEtc1ufMlROYsc31ctcFipNmEuAA1aBECEZAYJEOCEJkQjtJqxDYhaT1dQNI1a3NS0wG3ZRNBKsqKvStJcG1Xp4KRRgIBgL9QP0Uh1AEaAxFQAAFOj5kWWdpEQIlsMquJb2a1I5OfWQoVwebFuW1BxooDZEE2nhtpEXbwoO2IcXusrju8FBZHvYlmGYFAcQusCNwiARgb6orkGkA71v3Y8J2YCh9TPddLxkaHmFhy4EawO6HpRtGMdwc9IZxmH+vht4MCRmpjFlERvsQGxNu6fG6eQW1LIIuIvoepJNu8fBqX1XnhmGHAlIeIA" data-background-interactive>
            </section>
            <section>
              <section id="fragments">
                <h4>Summary</h4>
                <p class="fragment">Using function overloading you can be strict on the type return from the function</p>
                <p class="fragment">Using function overloading you can declare more flexible functions</p>
                <p class="fragment">When you have a function that receives union and returns union you should think about whether there is a relationship between input and output</p>
              </section>
            </section>
          </section>
          <section>
            <section>

              <h4>
                Typescript patterns
              </h4> 
            </section>
            <section>
              Discriminating Unions
           </section>
           <section>
            <h4>Let's implement network state log function</h4>
            <p>A function that receives 3 types of NetworkState, and uses different logic on each one</p>
            <pre>
              <code data-trim="" data-noescape="" class="language-typescript">
                function logger(state: NetworkState): string {
                }
              </code>
            </pre>
            <p>
              How would we implement it?
            </p>
           </section>
           <section data-background-iframe="https://www.typescriptlang.org/play#code/PTAEAEFMCdoe2gZwFygEwGYME4BQAXATwAdJQA5SfAdwQGsAZOAQwBMBLAOwHMBlfZvjIBeUAG9coUIgFDUAIgA2LDj3kBuXAF9NBEmUo16AMWbtFkVv0Ejxk6bMgKAZmYusN9gMZxWT0JwArgC2AEYwmjq4eqQUVLTQdLyBXl6QiIjWQqCiElIyNgqIKWkZnlLQ6cRwnIj+eVKg+Oz4Fqgy0Fzcmo2grIHQguw1qEFhEfb5IcHM0ITt+J08PaBRUSCgALTbXoH425sxBvH0WSL2AD5xRolMbF1nl9cJdKbmlo9SV4YvyanpmUcumcgU4XmaNVAym43BgAAoCnJnqdHABKBZLbh2KQbABK7G4AAt8AE4NRQAAVfS8LydYgk1hwdKkkl0Thk0DUQnsLyE0BwZxNQlkfCEyqQewbapCTjNZiKJr6RAOGygHyBRSsUDhAB00RxYApcy6TTgoGY-wy5tAxHgpGgRE53N5oHYiE4AHISYhCbNLJKwBb4Fb5QqiKRldRzArBm6yMxOKAYPBoPZEZAdT4-LoDaAAEKEaRR-C8k2Q9MAGkp1Np7HpaoTAVm8HJorIoOGnADfTJia4at8ZGcynJCflhEQbrTxZdCMcOvTqOxjS8zDqoCUKi68mQk0alXwA0T8gAIr3lPceDrr+UV2uyPJXO8PLvermKcLFbFgoEZNrjjcrxuB8jigMKlQVnuuaIGaFqlJOPBCmQAAGWaQMhoDOOwkCaq6yqIMwzgSm+oAHkeoDIQAorACCgAAJGI6aZoOWg9tQnAXqo3DISsUiruu8jFJaiA7lBpFUORyFnuxnGWPRjHzpUiDVLUGbNK0kCsZs8lMUpKl1Au0yzIQWg8fYWjaEAA">
           </section>
           <section id="fragments">
              <h4>Union Exhaustiveness checking</h4>
              <p class="fragment"> Because the switch is no longer exhaustive, TypeScript is aware that the function could sometimes return undefined. </p>
           </section>
           <section data-background-iframe="https://www.typescriptlang.org/play?#code/PTAEAEFMCdoe2gZwFygEwGYBsWBQAXATwAdJQA5SfAdwQGsAZOAQwBMBLAOwHMBlfZvjIBeUAG9QiAUNQAiADYsOPWaAC+AbgIkylGvQBizdvMit+gkeMnTIcgGbHTrWRtABjOKzuhOAVwBbACMYdS0iUgoqWmg6Xj93d0hERAshUFEJKUs5RASklNVNbUi9GLoDeACAYWZ3AAszNKss2wcqgH13OsairRLdaPpmjNxQUAAfKP1YpjYuPlsxyenyoxMmpfGpsuH85NStld3Yyrgans3LfpBQAFoH9z98B7vcez9Od3x2OE5QRTcbgwAAUKFWw1sAEpUFJoAtxMtENR2PgGqAwQA6bJCKGI8bjbqIMgKJQLWTIZYE0DQKh+aD-UnzHg0yAARz8yXwripHmYxNAskcGxclOp41p+Hp-wABsLnKAUfh6h4vGQACRiRCYzzeNQyrTUokkvKJA4U3kSukMwXcOD4VmIYh-Yk88ZqXBqIA">
          </section>
           <section data-background-iframe="https://www.typescriptlang.org/play?#code/JYOwLgpgTgZghgYwgAgDIHsDmoAicxzIDeAUMshALZzAA2AXMgM5hSiYDcZyADnE0wDu6KABNGLNiE4kAviRIQAHjxFhkoSLEQoAqk2h4CxbsHHNW7LuSo0GFqTPI8o6GHQgAFYAjABXKAgJS2kueUUVNWQwAE8eFAxsEABBX2B0EGQAXm4AH2JouKDkAHJUAHkAcQBJADkAfQAlAFEARV1mgGUAFRKODRAePzBGRNx8QnlyfKJC+MYyqrr6zt0AYTWuzr7kPwMoRn1DCeQp5Bm54sWahoAxZOrUZpwd6FcDh3ZTrgVNaHgkGgsKBOgRICZyHtoId9kY4KYmBg4KJ2IwAEbodC0CBwEDWChQd7BRxhBQIDIsAbAMDAOC0UH4YpjEAM8FZCG7faMEB+Wi0AA03DeIm5vIFCKRKOkjHgtAMcgUylUUHUMD8IDSGWQtGBIEaEFEfiQUAAFCxGdkqTS6ayIPzkIgaRlRrrUk6QABKF1JW0coTUhAAC2QJsd6RAADpYvEPRzyAh+ChrssWu0ur1GNxyORAv4oJkiBGi+bIPbgIj0MjUdEoH4IGd44nShUbit1ptOtt6Fns7mAgWixGS3aNBWq9LkLKDPaoR8wxkI7OG8gEwZm0s7g8ni9u9nexA8wPi2CR+XJdWpyPhXPNZHr8vRBB4LyRj2cwf+xZGfj5LIgA">
          </section>
            <section>
              Mixins
           </section>
           <section>
            <h2>Mixins</h2>
            <p>let's add a map</p>
            <pre><code>
        const map = new Map&lt;string, string>();
        map.set('1', 'something');
        map.set('2', 'another thing');
            </code></pre>
            <p class="fragment">
              now let's add a concatinate function to it.
            </p>
          </section>
          <section>
            <h2>take 1</h2>
            <pre><code class="language-typescript">
        class ConcatinateableMap extends Map{
        concatinate(): string {
          let total = '';
          for (const value of this.values()) {
            total += value + '\n';
          }
        
          return total;
        }
        }
            </code></pre>
          </section>
          <section>
            <div style="text-align: left;">
              <p style="text-decoration: underline;">pros</p>
              <ul>
                <li>simple</li>
              </ul>
              <p style="text-decoration: underline;">cons</p>
              <ul>
                <li>Need to create class for every type of class that has values</li>
              </ul>
            </div>
          </section>
          <section>
            <h2>take 2</h2>
            <pre><code class="language-typescript">class ContainableMap {
        private map = new Map&lt;string, string>();
        concatinate(): string {
          let total = '';
          for (const value of this.map.values()) {
            total += value + '\n';
          }
        
          return total;
        }
        }</code></pre>
          </section>
          <section>
            <div style="text-align: left;">
              <p style="text-decoration: underline;">pros</p>
              <ul>
                <li>simple</li>
              </ul>
              <p style="text-decoration: underline;">cons</p>
              <ul>
                <li>Need to create class for every type of class that has values</li>
                <li>Not really extends the class but hides the map inside</li>
              </ul>
            </div>
          </section>
          <section>
            <h2>take 3</h2>
            <pre><code class="language-typescript">type Constructor<T> = new (...args: any[]) => T;
        type ValuesConstructor&lt;ValuesType> = Constructor&lt;{ values: () => IterableIterator&lt;ValuesType> }>;
        function getConcatinatableMap&lt;T extends ValuesConstructor&lt;string>>(Base: T) {
        return class extends Base {
        concatinate(): string {
          let total = '';
          for (const value of this.values()) {
            total += value + '\n';
          }
          return total;
        }
        }
        }
        const ConcatinatableMap = getConcatinatableMap(Map);
        const map = new ConcatinatableMap();
        map.concatinate() 🤯</code></pre>
          </section>
        </section>
        <section>
          <h4>Exercise</h4>
        </section>
        <section data-background-iframe="https://www.typescriptlang.org/play?#code/JYOwLgpgTgZghgYwgAgCIHsDmyDeAoZZEOAWwgC5kBnMKUTAGgOQCM4oBrSgCgEpkAvAD5kAN3TAAJngC+ePKEixEKAMJwA7rmbEylGnRCNmJdOh79hYidLl4A9PeQBRABrOASqoCSAZWfIAIzkDk6qUBBwkMhwyDAAriAIYMDoIMhgABZRyBFIwKIQVBmZKBjYcCCSyKroWmAAngAORcjciakgvKHI3jDIwGC5EPmFxbGSWAzICHAANnMlKGyccYnJnTFVw2DxUOmxouzAcCxzKDBQ6CQZzWp10+hZ0BrAVBDTswtLyKboa0kUmkttUIrt9jExMdTuc4lcbo0WmgsD0ABKKSjxd6QzDxdjVbgkOANFgoWIJQGbLI5STAGAwaAQcAnSDFUlgDQQJk-RFFbp4CkbYEkBoAQRAwCJc24lUl80olQayHsACpKAB+dUq+z8VUarVOfCERwxSTVBroPYzdCSCAAOgdyFk8l5yAAchAOehOAAZdBwWlGQTaQgpMgAMXhHggAEd4kUwJQQPESKSoLIANwuu7uz0ab0ccNwYDnaoCEPW21JlNprMyLN4V0er2cXzxBBIKjFctGysUIg16BZwgRKhNNLvSi90ODc76Wj0YeEZCSPZRTrV1ND5iEKgpolQBrzwyYJf1zPyE3hSLRcnrIHpalDPIQAqtWIdYHofpZCIoZv5q2YBRCgvLjNsTSGGAxTPMgkHoC0UApK037IJECCZEQeYFj0gR2sgACq2LEFAVyvEYPQAEz4URKC0lQCB0CQoDrkGn4gFQPQAMw0dilRocmNxwOMtxInMgzQPMaIYjMEQgVh9Q5pc1xLNiYFOgK96bCA2GrNwo7jhx-aKsqKqatqvCUOIUgViaAbmpaUB9g6+GyEAA">
        </section>
        <section>
          <h4>Solutions</h4>
        </section>
        <section data-background-iframe="https://www.typescriptlang.org/play?#code/JYOwLgpgTgZghgYwgAgCIHsDmyDeAoZZEOAWwgC5kBnMKUTAGgOQCM4oBrSgCgEpkAvAD5kAN3TAAJngC+ePKEixEKAMJwA7rmbEylGnRCNmJdOh79hYidLl4A9PeQBRABrOASqoCSAZWfIAIzkDk6qUBBwkMhwyDAAriAIYMDoIMhgABZRyBFIwKIQVBmZKBjYcCCSyKroWmAAngAORcjciakgvKHI3jDIwGC5EPmFxbGSWAzICHAANnMlKGyccYnJnTFVw2DxUOmxouzAcCxzKDBQ6CQZzWp10+hZ0BrAVBDTswtLyKboa0kUmkttUIrt9jExMdTuc4lcbo0WmgsD0ABKKSjxd6QzDxdjVbgkOANFgoWIJQGbLI5STAGAwaAQcAnSDFUlgDQQJk-RFFbp4CkbYEkBoAQRAwCJc24lUl82QlHK-Eo6i0AvWQPSIvFculsqlCpqmmVyOw6spwrFEqlMut8sVWAAPkaNCbyshnartIQ6dw3uVbbreLx8IRCPr5gA6FYcPjMQgINI0X4NVUqzSCb1hwi6CjIADkItV+aY2cIfwsghEobLCaT6HOkbmWG4hbMAEJ2-nurW5Nm+2GwXstanNMwBxA5tia+G7XNI3847XEyBkyLyg7sAIs9nc5RCw1yiX42GY5WrDOyyuqA2IE2W-mNOh6cgn-TO92T4QB9+T0OIeuKK-nYgqagMVABhGcybp6xqUFB4Gmlm-7pIGBpwMUSrRuwHDIO2AjbokkgQDAoAQLY8i8sgAByEAcugnAADLoHAtJGJmNYpGQABi8IeBAACO8RFGAlAgPEJCklAsgANyUXcNF0U+nDcXAwDnNU241omxFiRJUlyTIcl4FRtH0ZwvjxAgSBUMUWnMDpebiZJ0ByYQERUE0SZ5peKRgOc+i0PQblhpIexRJ0ekuVAIWEFQElElADSBYYmAhUZsnyI4NQRFEZIAkK6TUkMeQQAUrSxB0wLPiUEQoGZykcL4YB5bcLTjNsTSGGAxTPMgXXoC0UApK0NWRAgmREEpDEcD0gSRsgACq2LEFAVyvEYPQAEwLctKC0lQCB0CQoARexVWrj0ADMu3YpUyBMhJMTjG1KBzIM0DzGiGIzLl0QgBA9QKZc1xLNivLFPIj03M1eXFDWviLaoqjOL4viZgARIjyOo74GOlsg3Git4jHOKgmNEyTZP48wjEAPKiqg3jUQA4pj9OM8zLMY7I8lIg1M3Max9Cw9E24C0xLFsdgABkuA0HllCi0UkYc0zrMZaZ00qWpGnK5mEscKp6nkcgcs4ArkBKy1rKRpTpOoJrCmG5Z1lFFQ+vi9rTVWTZxTm5bebK1QkbYyjaNO-z3vBwb3tC9L+vOobxt6zbKBJ9Hvvu8r8igZsAPmbh3AeV5q55i7adULwlDiFIO7UK8YATcXRSl+8kaB-wl4JhhKDB6rDPqyzITLvWjbNpgLeed5Hdpz2V5j3eE9T23d5cRAvHXPxQkifP2YsLlHCxWGszYv3Ye4yPC+rre96TyXM+d1+MyL3fK8zw-ZeRn55x7yfr-L0-u3IBd4wpQAimkP+dYb7jxbCAyM8D4okESg0KBrBD7Hx7mfSudtiYOyvtma8t9AGt0fnPZ+RDYH31IV-RyaCD6RCPuOWQQA">
        </section>
      </div>
    </div>

    <script src="../../dist/reveal.js"></script>
    <script src="../../plugin/notes/notes.js"></script>
    <script src="../../plugin/markdown/markdown.js"></script>
    <script src="../../plugin/highlight/highlight.js"></script>
    <script>
      // More info about initialization & config:
      // - https://revealjs.com/initialization/
      // - https://revealjs.com/config/
      Reveal.initialize({
        hash: true,

        // Learn about plugins: https://revealjs.com/plugins/
        plugins: [RevealMarkdown, RevealHighlight, RevealNotes],
      });
    </script>
  </body>
</html>
