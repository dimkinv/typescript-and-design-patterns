<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="../../dist/reset.css">
		<link rel="stylesheet" href="../../dist/reveal.css">
		<link rel="stylesheet" href="../../dist/theme/black.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="../../plugin/highlight/monokai.css">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
			<section>
				<h4>
					Advanced typing
				</h4>
			</section>
			<section>
				<p>
					TypeScript‚Äôs type system is very powerful because it allows expressing types in terms of other types.
				</p>
				<p>
					In this section we‚Äôll cover ways to express a new type in terms of an existing type or value.
				</p>
			</section>
			<section id="fragments">
				<p>
					1. DRY - Don't repeat yourself (related types)
				</p>
				<p class="fragment">
					2. Sometimes we don't have access to a type
				</p>
			</section>
			<section>
				<div style="display: flex; flex-direction: column; justify-content: center;">
					<h4>Part 1: Utility Types</h4>
					<p>TypeScript provides several utility types to facilitate common type transformations. These utilities are available globally.</p>
				</div>
			</section>
				<section id="fragments">
					<section>
						Partial Type
						<p>Constructs a type with all properties of Type set to optional. This utility will return a type that represents all subsets of a given type.</p>
					</section>
					<section>
						<p>for example - consider this interface </p>
						<pre class="fragment" data-id="code-animation" ><code class="hljs" data-trim data-noescape>>	<script type="text/template">
							interface Todo {
								title: string;
								description: string;
							  }
						  </script></code></pre>
					</section>
					<section>
						<p>Lets say I want to create a function that updates a todo  </p>
						<p class="fragment">I can pass to this function also a partial type:</p>
						<pre class="fragment" data-id="code-animation" ><code class="hljs" data-trim data-noescape>>	<script type="text/template">
							const todo1 = {
								title: "organize desk",
								description: "clear clutter",
							  };
							   
							  const todo2 = updateTodo(todo1, {
								description: "throw out trash",
							  });
						  </script></code></pre>
					</section>
					<section  id="fragments" data-background-color="white" data-background-iframe="https://www.typescriptlang.org/play?#code/JYOwLgpgTgZghgYwgAgCoHsAm7kG8BQyyYwYANhAFzIDOYUoA5gNyHKYQ0IMAOJ6IanQYgW+AL758MAK4gE-EMhk9McSBmwAKMFnTVN6ADTIYwCGUw0MAVVXqqyAApwoJOGQA8hgHwBKPDYoCDAZKCVcZAA6GN1sExioswsrW3tIZHFWSXwEATpiPQBGZABeQKISckcAInQoRjgQYAAvFA4aAGsaozYO7mA+YAFqGoQKV2RxmTBIKB6JVlz8sELsACYy5XSIQx1ikwIift5FUbAACyh0AHdkdBniKDgaC4XxP2YgA" data-background-interactive>
					</section>
				</section>
					<section id="fragments">
					<section>
						Required Type
						<p>Constructs a type consisting of all properties of Type set to required. The opposite of Partial.</p>
					</section>
					<section>
						<p>Consider the next example:</p>
						<pre class="fragment" data-id="code-animation" ><code class="hljs" data-trim data-noescape>>	<script type="text/template">
							interface Props {
								a?: number;
								b?: string;
							  }
						  </script></code></pre>
					</section>
					<section>
						<pre  data-id="code-animation" ><code class="hljs" data-trim data-noescape>>	<script type="text/template">
							const obj: Props = { a: 5 };
 
							const obj2: Required<Props> = { a: 5 };
						  </script></code></pre>
						  <p class="fragment"> This is an error!</p>
					</section>
					<section  id="fragments" data-background-color="white" data-background-iframe="https://www.typescriptlang.org/play?#code/PTAEAEFMCdoe2gZwFygEwHYAsBGAUAJYB2ALjAGYCGAxpKAArwAOioA3nqKJQPypEBXALYAjGAG5OoEX1CIS0YgHNJAXzx5qcIvNBwRAK1SM4LUAF523VAFZQqyZu279BtKgBKkAI4CC0SAATAB4TFgA+CytKW3txIA" data-background-interactive>
					</section>
				</section>
				<section id="fragments">
					<section>
						Readonly Type
						<p>Constructs a type with all properties of Type set to readonly, meaning the properties of the constructed type cannot be reassigned.</p>
						<p>This utility is useful for representing assignment expressions that will fail at runtime (i.e. when attempting to reassign properties of a frozen object).</p>
					</section>
					<section id="fragments">
						<p>Example:</p>
						<pre data-id="code-animation" ><code class="hljs" data-trim data-noescape>>	<script type="text/template">
							interface Todo {
								title: string;
							  }
							   
							  const todo: Readonly<Todo> = {
								title: "Delete inactive users",
							  };
							   
							  todo.title = "Hello";
						  </script></code></pre>
						  <p class="fragment">Error: Cannot assign to 'title' because it is a read-only property.</p>
					</section>
					<section  id="fragments" data-background-color="white" data-background-iframe="https://www.typescriptlang.org/play?#code/PTAEAEFMCdoe2gZwFygEwFYAsAGAUAJYB2ALjAGYCGAxpKACpwAmcoA3nqKCQSQDaRUiEtGIBzANx4AvnjzU4RYd2ZxUAJUiUWRPgE8APIxYA+UAF52nbrwGoARABFIAsqGI0eANzoBXRDCI9gA0MlJ4JKoAdDz8dJb2ABIufHD2EkA" data-background-interactive>
					</section>
				</section>
				<section id="fragments">
					<section>
						Record
						<p>Constructs an object type whose property keys are Keys and whose property values are Type. This utility can be used to map the properties of a type to another type.</p>
					</section>
					<section  id="fragments" data-background-color="white" data-background-iframe="https://www.typescriptlang.org/play?ssl=38&ssc=5&pln=30&pc=4#code/JYOwLgpgTgZghgYwgAgMJzASRDA9sgbwChlk4BzCALmRAFcBbAI2gG4TkmoIIATGgM5goocuwC+RImACeABxTowAOTgMUAXmQAiBsBgwZ25AB8dTXCIHGzuy7269t7IglwghyBBgE0AShBuULwAPEqq6gA0aBjYeAB8yFrEpHoGMjQEZJQ0AIwADNFcPPw6AArQAsBwIMbikRwWVpnZ1MgArEXcfDTaALJwoIq47nUNqfaOLRRtuQBsXSW9AEIiYMACABbIAMqblmCbg1BjROIuAPQXuVREV8gA7sAANs-IhxiPlgDWAPx3F2QoEgsEQKD6MgCQV4hABpGQAG1vhAMjEVGoIABdGhKOK4OGSAEAJlu9wAgiAgSBeBAAB7IKrkEAYOjcZByOBQDEg97yFAMOieFjIADkQhEIHIIuiIvozGg0tFAhkzFwz0VljI7wgDDkzwwKGewBBcDesgUADoABS5IlzAAcAEo4U9Xu8jmAvlA-nDgdB4EhkBCofZcrD7qQkSjBMJRGY5SwoKYGSqLM9sWi8QSpACAMykwGus0er0++5+0GB4OBexE8OAyPI1EAAwAJARxaJxABaYC8ZsZ3E4fH3Qn3NweT3eMACEnIEPBEJtjuxyXiTD96JDhJJYgR5BpQwb6Y5ZAFRY9cqVaq1ZD1OGkJobY+EVo0TqcbqlfqDEDDUZ3g0+4MJMfAvlkMx5Asn5LDoqzGhs2x7AcRzACcgEEkAA" data-background-interactive>
					</section>
				</section>
				<section>
					<section>
						Pick
						<p>Constructs a type by picking the set of properties Keys (string literal or union of string literals) from Type.</p>
					</section>
					<section  id="fragments" data-background-color="white" data-background-iframe="https://www.typescriptlang.org/play#code/JYOwLgpgTgZghgYwgAgCoHsAm7kG8BQyyYwYANhAFzIDOYUoA5gNyHKYQ0IMAOJ6IanQYgWbBOgC2PCpEzUARunQU4IVgF98+MAE8eKDNgAKUCADdgEAO7IAvMmPAEAawA8R9ABpkAIhLkEL7IAD5+EtKyEJi+AHys+BIgdMRY6NSephZWtg4ERAEU1L4AwqogyFDKkr5e4lIyEHLU8GQ0EHUaCWBprAD0fcgAegD8QA" data-background-interactive>
					</section>
				</section>
				<section>
					<section>
						Omit
						<p>Constructs a type by picking all properties from Type and then removing Keys (string literal or union of string literals).</p>
					</section>
					<section  id="fragments" data-background-color="white" data-background-iframe="https://www.typescriptlang.org/play?#code/JYOwLgpgTgZghgYwgAgCoHsAm7kG8BQyyYwYANhAFzIDOYUoA5gNyHKYQ0IMAOJ6IanQYgWbBOgC2PCpEzUARunQU4IVkW4Q4cgIJhqIAK6SF0VgF98+MAE8eKDNgAKUCADdgEAO7IAvMgA8pKkADxO6AA0yABEHFy8-CAxAHys+BIgdMRY6NQRrh5evgEERCTkVLEAwqogyFDKkjGR4lIyEHLU8GQ0EK2abjoQmPrUAIwAbOMArDMALPMATDNLAOxrAAytFulguawA9IfIAHoA-NZ2Dmi5AJIgMDgBwWER0TES0rIjMcgAPrEtMNRmBUulMtl9tgHk98vdHs88GwKhRqDFnMAEABrZBGHjIbHATA0FpseLcYB8YACdEAaVAHCgjDgUEg9QQZHQfRoyB0yBmPGaOz2CKeRxOFyAA" data-background-interactive>
					</section>
				</section>
				<section>
					<section>
						Exclude
						<p>Constructs a type by excluding from UnionType all union members that are assignable to ExcludedMembers.</p>
					</section>
					<section  id="fragments" data-background-color="white" data-background-iframe="https://www.typescriptlang.org/play?#code/C4TwDgpgBAKgDFAvFAogDwMYBsCuATCAHgCIBDYqAHymICMLriNiAaG8gPgG4AoAej5QhUAHoB+HqEiwAjElSZcBEuSo16apq3YN1xbv0HDxk8NBgAmeemz4iAZ2AAnAJYA7AOZq3OALa0IJzUACmCASiQOKAA3AHsXPDC2ADEcNwxgF1i3AwFhUTEgA" data-background-interactive>
					</section>
				</section>
				<section>
					<section>
						Extract
						<p>Constructs a type by extracting from Type all union members that are assignable to Union.</p>
					</section>
					<section  id="fragments" data-background-color="white" data-background-iframe="https://www.typescriptlang.org/play?#code/C4TwDgpgBAKgDFAvFAogD2AJwIYGNgA8ARNkVAD5REBGZlRuRANFaRVQGZEB8A3AFAB6QVFFQAegH5+oSLACMSVBhz4CAZywBLAHYBzdjoCuAW2oRM7ABRWAlEm5QAbgHstAE1ssAYkZ34tFx0+IRExKSA" data-background-interactive>
					</section>
				</section>
				<section>
					<img  width="800px" height="685px"   src="../../assets/utility.jpeg" />
				</section>
				<section>
					<section>
						NonNullable
						<p>Constructs a type by excluding null and undefined from Type.</p>
					</section>
					<section  id="fragments" data-background-color="white" data-background-iframe="https://www.typescriptlang.org/play?#code/C4TwDgpgBAKgDFAvFAcgewHYoK4BtcCGARrhADwDOwATgJYYDmUAPlBtgLZETUtTYYAJhABm9CIIB8AbgBQAenlRlUAHoB+WaEiwAjElSYc+YqUo16DANoBdPu3x8BwsRgkyFSlRqA" data-background-interactive>
					</section>
				</section>
				<section>
					<section>
						Parameters
						<p>Constructs a tuple type from the types used in the parameters of a function type Type.</p>
					</section>
					<section  id="fragments" data-background-color="white" data-background-iframe="https://www.typescriptlang.org/play?#code/PTAEAEFMCdoe2gZwFygEwGYAsWBQATSAYwBsBDaSUAMwFcA7IgFwEs56aBGACgoHNUAb1BlU9WgFsARjADcoKakRNoLen1ABfAJSoAbnBb5ZuXEwCeAByoAVAAygAvKAAKFMhMhMYiADzdtJwA+UGVVdSCTEFAY0AA9AH4zK1tOJ1d3T28kfxRQlTU+QMcQgyNI3GjYxOTrUBs0dLdoDy8fX18bIN5oAXrikK6osGqkizqbDCbMtpzxyDhqLgqqmJr5+qxplqz2snpzFZG1sZT6gFZt1uy-ekg9GCPY+NOJgDYr3ZywwqfR2tsAHZPrM-AAxBjMNj0P4nIA" data-background-interactive>
					</section>
				</section>
				<section>
					<section>
						ReturnType
						<p>Constructs a type consisting of the return type of function Type</p>
					</section>
					<section  id="fragments" data-background-color="white" data-background-iframe="https://www.typescriptlang.org/play?#code/PTAEAEFMCdoe2gZwFygEwGYAsX3awFAAmkAxgDYCG0koAZgK4B2pALgJZxP0CMAFAEpUAb1CVUTBgFsARjADcoGakSto7JgHNQAX3kECrAJ4AHWgBUADKAC8oAEqRWDaE3OnIAHkG2AfKFV1LV99EFBw0AA9AH5DD1BzHlsHJxc3D28UALUNTQE-UAA3OHYiEIIwiJi4swS0ZMdnV3czT09zXx8bfw7QsCrY41rzDAbU5oz20EgAD1ZIJiJEUABVABpV6bmFpdBJWRgAbQBdTvzuhPLK8Oqhi1w7RrSWrzu4Ol4r-pvB+PMAVjGTXSrUoTCMXwiUV+wwAbEDnhkmJBCjBIQMahYAOwIiatQK5dE-TEJAAcuJBXgAYsw2JwmEToUA" data-background-interactive>
					</section>
				</section>
				<section>
					<p>InstanceType</p>
					<p>ThisParameterType</p>
					<p>OmitThisParameter</p>
					<p>ThisType</p>
				</section>
			<section>
				<div style="display: flex; flex-direction: column; justify-content: center;">
					<h4>Part 2: Creating Types from Types</h4>
				</div>
			</section>
			<section id="fragments">
				<p>
					1. Sometimes we don't have access to a type and we want to make sure we send the correct value 
				</p>
				<p class="fragment">
					2. Sometimes we want to create our own utility types
				</p>
			</section>
			<section id="fragments">
				<ul>
					<li>1. Keyof Type Operator </li>
					<li class="fragment">2. Typeof Type Operator </li>
					<li class="fragment">3. Conditional Types </li>
					<li class="fragment">4. Indexed Access Types </li>
					<li class="fragment">5. Mapped Types </li>
					<li class="fragment">6. Template Literal Types</li>
				</ul>
			</section>
			<section>
				<section>
				<p> Keyof Type Operator </p>	
			</section>
			<section>
				<p>The keyof operator takes an object type and produces a string or numeric literal union of its keys. The following type P is the same type as ‚Äúx‚Äù | ‚Äúy‚Äù</p>
			</section>
			<section id="fragments">
				<pre data-id="code-animation" ><code class="hljs" data-trim data-noescape>>	<script type="text/template">
					type Point = { x: number; y: number };
					type P = keyof Point;
				  </script></code></pre>
				  <p class="fragment"> type P = keyof Point </p>
				  <p class="fragment"> type P = ‚Äúx‚Äù | ‚Äúy‚Äù: </p>
			</section>
			<section>
				<h4> practical examples:</h4>
			</section>
			<section>
				<pre  class="fragment" data-id="code-animation" ><code class="hljs" data-trim data-noescape>	<script type="text/template">
					function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
						return obj[key];
					  }
				</script></code></pre>
			</section>
			<section data-background-iframe="https://www.typescriptlang.org/play?#code/PTAEFEA8EMFsAcA2BTUBGAXKAUAFwJ7yoAi0uyACgE4D2RVBAcnMgM6gC8oA1svjQDNQpcnkIkyyAMq4qASwB2Ac2p1kDfM1htOwyavpMW7AGShWsxUrFE95KflgAjGogPqj29lxGVahzWNQM1ZHF0RsSOwBAFcFAGNcORoFUCVkXHcNAB4AFQAaUABpUGRIcgUAE3ZefiFcgD4AChonACssAp4+LCKASk6AbSKAXVAAb2xQUCoMmKpU1rbB2pGAbmwAX0iQCBgEFFAAJiwbVABJBQEaXUmASAUWLAt5ZXzsO9ZoRGgqfCwFDFnOotpF4ikLKBKsgAG7IRBqKhYS7XW5TUCPbRYADkAEFoKwBNj3tMvj8-lg0AAGKmFLYbbDghSQzHIXLiXTpTL+Dz4JrQuEI+iFbGs7F9NagXYvKw4bC7ADCNAQchQVFKVFo6sZENw5m+v3w7NsXC5WQI-Nh8MRIvg0Hw4slIAV0AUChoeoEikqGJYoGxdodADomkcAMxUgAsfSi8rAUDgSFQYdOBFsADFkGR5sh0z8lN4JjhppVftwALI0aFYJp9TgNUAwmhySobaYKZAAdwAqqx1KovSga3WOA2my3JfTImnUJns7MAPLwJIQ3QAJWQ4KolWytUEoDnuBzeegBcKLlcWYUDUnQA"></section>
		</section>
		<section>
			<section id="fragments">
					<p>Typeof Type Operator</p>	
				</section>
				<section>
					<p>The Typeof Operator has already been used in type guards. Deriving a type into another type is another use of it.</p>
				</section>
				<section>
					JavaScript already has a typeof operator you can use in an expression context:
				</section>
				<section>
					<pre><code>
						const hello = "Hello world"
						console.log(typeof hello);
					</code></pre>
					<p class="fragment">What will be printed?</p>
				</section>
				<section>
					TypeScript adds a typeof operator you can use in a type context to refer to the type of a variable or property:
				</section>
				<section>
					<pre><code data-noescape>
						let s = "hello";
						let n: typeof s;
						   
						let n: string
					</code>
					</pre>
					<aside class="notes"> 
						How many types are in Javascript?
					  </aside>
				</section>
				<section>
					<pre data-id="code-animation" ><code class="hljs" data-trim data-noescape>>	<script type="text/template">
						function f() {
							return { x: 10, y: 3 };
						  }
						  type P = ReturnType<typeof f>;
					</script></code></pre>
					<p class="fragment">What will be that type of P? </p>
				</section>
				<section>
					<div>
						type P = {
							x: number;
							y: number;
						}
					</div>
				</section>
				<section data-background-iframe="https://www.typescriptlang.org/play?#code/PTAEFEA8EMFsAcA2BTUBGAXKAUAMwK4B2AxgC4CWA9oaLpZQBQB0L0ATgOYDOW0hAngG0AugEpQAb2ygZoNslL42NKbLW16mUAHIupNuUIdtAGmnqZdSgCYsu-YeNmLl+gGY7eg0dPmLVgBZPBx9nFysAVmDvJz91KwA2LEk4lw1KAHZQLDQwtNdKAA5s9Dz8qwBOLFV8i1JkPSwGcQBeAD4deUVlLlBiSgREcmJoeoATUEoAIwArZDJtVJcAXyWZVbVV1exSfnhUADF6UBbQXf3KXHSdvdQAJQUlQgAVW8ujyhPQB+6X24Aec7IS7pNrYcEgCAwQaoWw4aBcfgkWhEMhUGiwaCGZopGT9Qh6UDQeDkB5ceDULioU7QADuWNIoAACmwBuQqUxoIhEAxBHFcApiAALBgAIiFpFI8B4IGQ0KQyCY-VgotEZRZbI58i4lEQADdkGLnuRSHxyPhYKAAOpCk3IVVhMTScxA0AAQRJZIpBOQr32XyBIOJpIa3qp2G22Ehbr6A1g1FA+Cpkyugau7LOn2mpsMRLOtzkyHg2uQhAoRjOQtQgBwCPSjYagLh2wC4BCm88REAiuFGwAxYMgzUYsPivPgyJQ2CZG6aKMRQMXKPs2BQGlO+BNKKQq2xK45eoRN-OS2XJjQ+KBDHWSKgQVvUB2u6IIWAoHAFaAPDgH1xegc2PgTVxWMCX0MdSAnBg4ngfApiGOd5GgMZqEQfhQEIOBkCwLxHDKaDYIbBCkMIFDQExH8sEIC0pmQScoJguDC0Q5DUP6RAJywkIOHMcQJA2cw61nPoEPqAAhPhxJxGoZC6J40OQWlQD-ADSDFKZxPQ0UpzQAAGQop1FfhkG5ShaVVcwtmdEdGQAWX4JTANOezSDWL9KUZNT0PQr4nKVYTkDEzzoGaIA"></section>
			</section>
			<section>
				<section>
					<p> Conditional Types </p>
					<p> Conditional types help describe the relation between the types of inputs and outputs.</p>
				</section>
				<section id="fragments">
					<p>Consider the next example: </p>
					<pre class="fragment" data-id="code-animation" ><code class="hljs" data-trim data-noescape>>	<script type="text/template">
						interface Animal {
							live(): void;
						  }
						  interface Dog extends Animal {
							woof(): void;
						  }
					</script></code></pre>
				</section>
				<section>
					<pre data-id="code-animation" ><code data-trim data-noescape class="hljs">	<script type="text/template">
						type Example1 = Dog extends Animal ? number : string;
					</script></code></pre>
					<p class="fragment">type Example1 = number</p>
				</section>
				<section>
					<pre data-id="code-animation" ><code data-trim data-noescape class="hljs">	<script type="text/template">
						type Example2 = RegExp extends Animal ? number : string;
					</script></code></pre>
					<p class="fragment">type Example2 = string</p>
				</section>
				<section>
					<p>Conditional types take a form that looks a little like conditional expressions (condition ? trueExpression : falseExpression) in JavaScript:</p>
					<p class="fragment">SomeType extends OtherType ? TrueType : FalseType;</p>
				</section>
				<section data-background-iframe="https://www.typescriptlang.org/play?#code/PTAEFEA8EMFsAcA2BTUBGAXAKCwY0dAM6GgDiATgJaKKgDeWoohALtOS6UQBQCU9AX0bMWAe3hdCfQViH4iJAPIA3ZADt6wwshYAVZAmTloLAK7lk3ACbIA5heSEMoNadgAjI-zpChoLCwAnvCoAMKiogDWlGq2ACLIypS4yAA8ugB8oAC8oLqgyJAs6lYkAET21IhloAD8ZFQ0oM4q6oxYKCygNkkpmKDhUTHxiclpFY3VGcJMTB063aMpAEzOg9GxCb3joqpqZdM4QSGgAII5mgCQ0M6sVLEANFiX7s6uHkayAcGoAEIXDEuuFuLHutgA2gBdJ6XKxvNyechQr44EAQGAIFCgVZYABmpjUuBYlFEGkIolgyAAYgSiSS1OkMtxlNBEKZkBhdLxAbhSaxmBTkIoWAALIw0wnE0kXbjPcmU07kWzOfKFYpqUqgdwRFDQDT1c7Of7PfjZLKAy6UXHcADk0BtoBiAoVSqY3Oel0u8uQitsADpoB6hJ7kIhtFdPd7fX7cEHnkILGZyGTBcKxeQJXTSQBuFG8tT8iyEUyILq5Z3U2lStS2u7DG28XOosAARVMlAAXs1vic9YQAO5GAD6aAuADYACwFIolEjvRF1UCg9nNUC41naHuoPuD8hD5YXedGafqzWTxfL1DOddh5Bb0A74cAZguddiUJPs4fakCF-IK+vDc72ObcC13Icp1yN8IUhT8NRIPVAg-epL1XG9NxA78B2HABWQ9EmPNUv0Qv8ALXID70fPcxwuEiiPg79fxQ-8r3I29KLA4cAHYLjiExUHozU6BcZB+1Abg-Uk9hbCcRioV4ZwSL8RclxY4RAPYzCqKHAAOC4QNEXFQD44o4KEkSxIkqSlVkxD5MUn9QGU+pVPZdS2O0IA">
				</section>
				<section>
					<p>Distributive Conditional Types</p>
				</section>
				<section id="fragments">
					<p>When conditional types act on a generic type, they become distributive (like a loop) when given a union type. For example, take the following:</p>
					<pre class="fragment" data-id="code-animation" ><code data-trim data-noescape class="hljs">	<script type="text/template">
						type ToArray<Type> = Type extends any ? Type[] : never;
					</script></code></pre>
					<aside class="notes"> 
						If we plug a union type into ToArray, then the conditional type will be applied to each member of that union.
					  </aside>
				</section>
				<section id="fragments">
					<pre data-id="code-animation" ><code data-trim data-noescape class="hljs">	<script type="text/template">
						type ToArray<Type> = Type extends any ? Type[] : never;
							type StrArrOrNumArr = ToArray<string | number>;
					</script></code></pre>
					<p class="fragment">  type StrArrOrNumArr = string[] | number[] </p>
				</section>
				<section class="fragments">
					<p>in the case of conditional types the "never" has a different role.</p>
					<p class="fragment">here, never means if the condition has met (or not met) don't return anything</p>
				</section>
				<section>
					<h4>for example</h4>
					<pre data-id="code-animation" ><code data-trim data-noescape class="hljs">	<script type="text/template">
						type OnlyNumbers<T> = T extends number ? T : never;
						type MyNumbers = OnlyNumbers<64 | 23 | 34 | 'hello' | 'world'>;
					</script></code></pre>
				</section>
				<section>
					<h4> Examples: </h4>
				</section>
				<section data-background-iframe="https://www.typescriptlang.org/play?#code/PTAEENQZwUwF1AewGamYgrgJ2gBxgMYCWyRBocAFkQHYDmUAUHAJ76gBi4AbolkXBgBhRABs+UUAF5GoUAB9QAIgAm4LAGtoRGDRrglshcu7gaoFSw0xQAIyyIA7jUNzFSljFHjHSApSwYV2MlKHBcUDpA3WD3OAEzIgwAW1BHakFY5VxKKnBxSOiXI3dcLAwoKCIzO1EMIJLlAnAVJNTPbycsgG0aFNsYLAAaUD7kgeHR-sGAXUaAb1BAlQAuKfHBgG5CmF01sYnt2zqYfemcAF9GRhAAUQAPcGTcURsARlAHuCxwAjg15hsGwAZW+tDoInEWEkUk+92+vzgAB4uLx+IJIRIRlAwfQAHzXO6PZ6vUAAJjhCL+ANY7AA8rYAFaEOCY6HSSk-P4onh8ATCMRY0CLZZnDaXAk3YAPJ4vGwAZk5iJpQNAABUMHK2Uw5LCvlzkai+RjBdCRr1ziMDoMrecZpKibLSQAWOEEOoqU6gQHsAByiBooP49G1HIe7ownp5aP52uxuLokuuyZTKeAACp07J026PTZkA5UmqKJRELAKEDJHkEOobOBKkQ6PpjjY4IhQABVbPAH02ACyLHDeaRapGHbxHOLMHhuhUkg7oAA-KMYNxBqA1mqbpns0q-mhC+qS2XW5WS+Aa4EIA2m+AWxR213QOme7T+4P4QaR2OJ7CpzOaDnTslyPfZV0GIA"></section>
				<section>
					<p>the infer keyword</p>
					<p>Conditional types are not just for switching behavior based on comparison ‚Äî they can be used with an ‚Äòinfer‚Äô keyword to access sub-parts of type information within a larger type</p>
				</section>
				<section>
					<p> This keyword, which can only be used in the context of a condition expression (within a conditional type declaration) is an important tool for being able to extract out pieces of type information from other types.</p>
				</section>
				<section data-background-iframe="https://www.typescriptlang.org/play?#code/PTAEFEA8EMFsAcA2BTUBGAUBgLgT3qgJIB2AZsgE4DKA9rMtgBYCWxA5gDwAqAfKALyguoZJGzJiAEwDOoAN7QAXKFbkKoAIIAaUACNlxAK6xdlAL6gA-JuXRiuLHgKgSaiskloBLspVr0mVk4FZWlsCiCdfVAjE3MeHHwiXwp3SQAmb1c-OgYWdg4Q0DCI9jMEp2S3DwBmLJT-PKDCpWLwyL1FXRoaFDtyrBAIGAQUUHSMAGNEaGlZAHVkXXhoSYBrAGE6eGYUdTkMUFBJmmISw0nsGgoAChp4bGZT6WUDo6O4SUtlUmhEaVQAB95KAANqsSSiULtdgAXVs9lAZkO7100F23z0PT6xBRR0mq0YyG+ePewO6vWQdlJR2Bb3eDKOsGgkAA4hJKNBHs9MbFTBQaYzKsoAET0WDXXAiwVHZGkk7EcRiTElIKkyEEKQSSbMZDSFUwtig2Hq5AANyuvQNpTYoGBv3+yFJEnCuGtaoZk0YhmIawAMjRoJIgu72HbQA6AVgGRqJJIAPLEUO24Gq9jG0kzXCUXmGRCIcNptikig+x70ZPR94Ad1msADQZD0Jt4cjTudYkoxD+0i4SRJjPDIrN0Ao0sHwLFNEkeeQ48Zk9m0mYbGI84Zk8C0nXZNAIurEJo1Z3tL3AMQpBPQ7YiBoaMQV8nJ1gEuIACtt4Kn3RXx-0o+92fX9pAAWglGcUAAkVPigz4QPcABHQxmHcKDjEkNDYAyKCP1OeAoOkXAwmQWAoPgCg6GYAEoOYBBrmwAjJgiB5pVJFdiGuZB5lHYggn1ZQbi-UAACVkDYKB4CE+lByOUhdmJZRRPEyBJJld56DmaA2AUkSxIkqsZNAcDZ0xJT9MM5EGQASgzTNA0hChMTkMEIShNobXhUA7FwJFSXAnSRUhM1kFveB6EVEUh3I6cLm5Nchw44g51JbsK2bD13hWCg-hQRAqNgXM4gFBlorklBMQpHES2QE4KBkEh4EMbAAAUuUYZNWx7J0GXcWqZHjJrGpatqOvtLrqr66RWqYUaI3Ghkwi5fihMqqlcQnPdEuSjaRWkYxmQoKUhJFSgKIoUDTkQI6dtO65QNrChePYT8dtgVhaL+KCOIoZkH2OyFsHRFAMOO4KKG6aiDNAQGKG07BZrbQtDVshla2wL0KuxNaUTMKz5GROUFTCY5SDYLxBHpF1DtFaQKEmYBXMgAA6bBty0FFqyar1lHCQxkB0IYqGa8A-T9QgADlWQgYThPjYSAEJ5YwZFXXkFEiewY5tnk9RBCS6tQEWZZVk2bW9huSZSas5Xji5L1QBuU68fpJgKIN-WIFSa5BIZAADZqKN0FBYC1hBdiCUADyYLWyBXAAdYgABI5AAKSoeNxaZotmFIXAfcZS22HZwcjHzYvGUivdSSssxfZRa25QwEAwBA1vJia1uQMSZwtjOXnLmuDRYY4DY+EEDYRE7KRZHpD2blHNhlFUShNCshEHEsqxNBRAxzUoLBpiXUAADFS2YbAqEBqQ1fxZ5+6uW5SDP7BxbgPV0vTWFnYJrAUE1p-kKs2UL3c4A8KBD04JUGgpAT7P0vnYSQCQ-6hx2HseMDwnhnGAXfUsYCIEcCgTAo2Kx1hbDDnsBIB874kzYOkbBfdcEP3wYQw2SwSGm3IZQPg3hKaKmpmeOmDMtTM1ZiKcunN0aMB5qWfmoBBbC1FhLKW4AZZy0VsrIAA"></section>
				<section id=fragments>
					<p>Function‚Äôs first argument:</p>
					<pre  class="fragment data-id="code-animation" ><code data-trim data-noescape class="hljs">	<script type="text/template">
				type GetFirstArgumentOfAnyFunction<T> = T extends (
					first: infer FirstArgument,
					...args: any[]
					) => any
					? FirstArgument
					: never
						</script></code></pre>
						<p class="fragment">
							type t = 
							GetFirstArgumentOfAnyFunction<(name: string, age: number) => void> // string
						</p>
					</section>
					<section>
						<p>Function‚Äôs second argument:</p>
						<pre  class="fragment data-id="code-animation" ><code data-trim data-noescape class="hljs">	<script type="text/template">
					type GetSecondArgumentOfAnyFunction<T> = T extends (
						first: any,
						second: infer SecondArgument,
						...args: any[]
						) => any
						? SecondArgument
						: never
							</script></code></pre>
							<p class="fragment">
								type t = GetSecondArgumentOfAnyFunction<(name: string, age: number) => void> // number
							</p>
						</section>
					<section>
						<p>Array type:</p>
						<pre  class="fragment data-id="code-animation" ><code  data-trim data-noescape class="hljs">	<script type="text/template">
							type Flatten<T> = 
								T extends any[] ? T[number] : T;
							</script></code></pre>

						<pre  class="fragment data-id="code-animation" ><code data-trim data-noescape class="hljs">	<script type="text/template">
							type Flatten<Type> = 
								Type extends Array<infer Item> ? Item : Type;
							</script></code></pre>
							<p class="fragment">
								type t = Flatten<[string, number]> // string | number
							</p>
							<aside class="notes"> 
								Here, we used the infer keyword to declaratively introduce a new generic type variable named Item instead of specifying how to retrieve the element type of T within the true branch.
								This frees us from having to think about how to dig through and probing apart the structure of the types we‚Äôre interested in.
							  </aside>
						</section>
						<section>
							<h4>Exercise</h4>
						  </section>
						  <section data-background-iframe="https://www.typescriptlang.org/play?#code/PTAEFEA8FMCcGMCWBnaoCMoBQXgCosAxRWZAF1AHsAzUAQVlgEMBPLUUAWm58-dABGLegDsyAC0ojhhAK6gAFAAEmY6rICUoAMTQmyYdqaNWODtougAirOjlEUs6ACSAWwAOAG2ivoY0EygAOZ+cIjwoAAGxKRkADwAKgB8kaASTBRkTADWdgEi9CbCkQmpqgAmoLDQZLKwIsigiGSN1CTkoNDevmIA5I1kLO7QAHROhJSwnZBMHt4AXE6Ryy38g8MBjJgAvKAA2r1MvQA0oL0CJ2fwvQC6a0NoxrAATKC7ewDMp8+n6Hf3G3EenKO1AMXIcSe6CSoBA02G8DI0EqZEogjQh16ALQQKY5Veu3B8SezxhcOgkARSJRaIEaA+-GWkScMIAaohoAB3KgFADizQAErIBPNQOIyGR3Mh5iAWvBxCMAFbIEaTILAdAAFiweGAOHwoAA+saTaaTaAAJqUOqgADClHKaAFcDQZrdxtAupw6zQRMS0yRInKjVULD2Nxhu1D+rwRvdZtACTsFFt+jy8YTXsQHkmmQeoAA3hAAI6yJieU5QKmgAC+oGosEorjOSh9nHl5e8IhCyGAsjIiE8yCxWB9oHgaca734VegiLi4FL5bifs+31+EdOHySSWOM8pc-ii7LnhX7XiewUWm2MPQzy+hYCovIsEQ3drm8U19v953e44s7zsey6rp+IjQAAbnAf77lSC5Lqeq6yEG0BtOB5SfshjpociMH-GOcCNqQbz7PwcKtsgnAUlSVGMJM-B+r0IiUGQDDMCwvS7mRYAUVRB6IrRREMeecRFgADKKhxFAAMoguS9LWXH-AaGammCdQSHAoAAMpIlKcaqYanp6vg-Awtp4jGGgLDWlMyCUJ4-YOA0oripK0qysg8pKiqaoapqwCqMgnJwGZoDslyoD2Y5A5SNKYoSlKMrAHKCrKqqsDqlqwDRU5cVhQAspMaC2pZnhdj2rmJR5KVeWlvmZTqepAA">
						  </section>
						  <section>
							<h4>Solutions</h4>
						  </section>
						  <section data-background-iframe="https://www.typescriptlang.org/play?#code/PTAEFEA8FMCcGMCWBnaoCMoBQXgCosAxRWZAF1AHsAzUAQVlgEMBPLUUAWm58-dABGLegDsyAC0ojhhAK6gAFAAEmY6rICUoAMTQmyYdqaNWODtougAirOjlEUs6ACSAWwAOAG2ivoY0EygAOZ+cIjwoAAGxKRkADwAKgB8kaASTBRkTADWdgEi9CbCkQmpqgAmoLDQZLKwIsigiGSN1CTkoNDevmIA5I1kLO7QAHROhJSwnZBMHt4AXE6Ryy38g8MBjJgAvKAA2r1MvQA0oL0CJ2fwvQC6a0NoxrAATKC7ewDMp8+n6Hf3G3EenKO1AMXIcSe6CSoBA02G8DI0EqZEogjQh16ALQQKY5Veu3B8SezxhcOgkARSJRaIEaA+-GWkScMIAaohoAB3KgFADizQAErIBPNQOIyGR3Mh5iAWvBxCMAFbIEaTILAdAAFiweGAOHwoAA+saTaaTaAAJqUOqgADClHKaAFcDQZrdxtAupw6zQRMS0yRInKjVULD2NxhuwSAb8wf2iBE1DgYPaZFOIwzCaTUwASnYyDdQAB+FOxUCikTQABucH1eCN7rNoAS+bt+jyjabXsQHkmmQeoAA3hAAI6yJieU5QKmgAC+oGosEorjOSh9nHlE+8IhCyGAsjIiE8yCxWB9oHg7ca7340+giLi4DHE7ifs+31+EdOHySSWOt8pe94ifcdPFfVM4j2BQtG2GF0GeL4hwCUVyFgBMgjnL9FBguCEN-f8ODvB8QJfN8sMrGtYHwgCqUfZ8wLfWQg2gNpK3KLCmMdVjkWo-5zzgJdSDefZ+DhNdkE4CkqUkxhJn4P1ehESgyAYZgWF6P9RLAcTJMAxEZME+SIOHAAGUVDiKAAZRBcl6OdNP+A1O1NME6gkZMAGUkSlBtnMNT09XwfgYQ88RjDQFhrSmZBKE8A8HAaUVxUlaVZWQeUlRVNUNU1YBVGQTlaw4NkOW5GK4sPKRpTFCUpRlYA5QVZVVVgdUtWAcr4qq4LQAAWUmNBbTCzxt13JLatShr0qarLWp1PUgA">
						  </section>
			</section>
			<section>
				<section>
				<p> Indexed Access Types (Lookup types) </p>	
				</section>
				<section id="fragments">
				<p>At the simplest level, these kinds of types are all about accessing some part of another type, via an index.</p>
				<pre class="fragment" data-id="code-animation" ><code class="hljs" data-trim data-noescape>>	<script type="text/template">
				type Person = { age: number; name: string; alive: boolean };
				type Age = Person["age"];
				</script></code></pre>
				<p class="fragment">
					type Age = number
				</p>
				</section>
				<section id="fragments">
				<pre data-id="code-animation" ><code class="hljs" data-trim data-noescape>>	<script type="text/template">
					type I1 = Person["age" | "name"];
				</script></code></pre>
				<p class="fragment">
					type I1 = string | number
				</p>
				<pre class="fragment" data-id="code-animation" ><code class="hljs" data-trim data-noescape>>	<script type="text/template">
					type I2 = Person[keyof Person];
				</script></code></pre>
				<p class="fragment">
					type I2 = string | number | boolean
				</p>
				<pre class="fragment" data-id="code-animation" ><code class="hljs" data-trim data-noescape>>	<script type="text/template">
					type AliveOrName = "alive" | "name";
					type I3 = Person[AliveOrName];
				</script></code></pre>
				<p class="fragment">
					type I3 = string | boolean
				</p>					 
				</section>
				<section id="fragments">
					<p>Another example of indexing with an arbitrary type is using number to get the type of an array‚Äôs elements. We can combine this with typeof to conveniently capture the element type of an array literal:				</p>
				<pre  class="fragment" data-id="code-animation" ><code class="hljs" data-trim data-noescape>>	<script type="text/template">
					const MyArray = [
					{ name: "Alice", age: 15 },
					{ name: "Bob", age: 23 },
					{ name: "Eve", age: 38 },
					];
				</script></code></pre>
				<pre  class="fragment" data-id="code-animation" ><code class="hljs" data-trim data-noescape>>	<script type="text/template">
					type Person = typeof MyArray[number];
				</script></code></pre>
				<p class="fragment"> 
					type Person = {
						name: string;
						age: number;
					}
				</p>
				</section>
				<section id="fragments">
				<pre class="fragment" data-id="code-animation" ><code class="hljs" data-trim data-noescape>>	<script type="text/template">
					type Age = typeof MyArray[number]["age"];
				</script></code></pre>
				<p class="fragment">type Age = number</p>
				<pre class="fragment" data-id="code-animation" ><code class="hljs" data-trim data-noescape>>	<script type="text/template">
					type Age2 = Person["age"];
				</script></code></pre>
				<p class="fragment">type Age2 = number</p>
				</section>
				<section id="fragments"> 
					<p>You can use a type literal in order to index access other types </p>
				<pre class="fragment" data-id="code-animation" ><code class="hljs" data-trim data-noescape>>	<script type="text/template">
					type key = "age";
					type Age = Person[key];
				</script></code></pre>
			</section>
			<section>
				<aside class="notes"> 
					Now let see how we can use index access type, the keyof operator and generics to create more complex types
					lets say we want to create a generic function that receives any object (T) and any objects key and returns the property in this key
					describing access to any property in a given object
				</aside>
				<p> for example: </p>
				<pre class="fragment" data-id="code-animation" ><code class="hljs" data-trim data-noescape>>	<script type="text/template">
					function getProperty(obj, key){
						return obj[key]
					}
				</script></code></pre>
				</section>
				<section>
					<p>What should be the type of value?</p>
					<pre class="fragment" data-id="code-animation" ><code class="hljs" data-trim data-noescape>>	<script type="text/template">
						function setProperty(obj, key, value) {
							obj[key] = value;
						  }
					</script></code></pre>
				</section>
				<section>
					<pre class="fragment" data-id="code-animation" ><code class="hljs" data-trim data-noescape>>	<script type="text/template">
						function setProperty<T, K extends keyof T>(obj: T, key: K, value: T[K]) {
							obj[key] = value;
						  }
					</script></code></pre>
				</section>
				<section data-background-iframe="https://www.typescriptlang.org/play?#code/GYVwdgxgLglg9mABAcwKZQAoCc4AdVZQCeAPACoA0iA0oqgB5SpgAmAzogNapFzCJkAfAAo4AIwBWALgFVuRGdQCUiAN4AoRIizoQWJOIkBteQF0A3IgD0VxAEkwwAjpaJi+RDA5kj1U+oBfdVBIWARENnRsPAJicipaBiZWDnk+ARFDGUouHkUqADcAQwAbEFRs31MVDS1DEx5TRABeRGKy1HNA9RL0RHoWtURgODgZAEYABioxIqwZACIAC1QSkrgAQgXEAK7eqGHRwbRMHHxCImF6KgWRuAWlSxtEMBAAWzECHr7ZrGOos6xS7XRALX4PJ62NhQLAwMDIb4HUa4DitE7Rc7EK43ADuc2QczEJQh1lsAFEsDgsBtQXisASsETtl4XnADrdRtsAD6g8HqSKnGIXbGgu4LG7Q2HwknPClUjZUSVw5B0ej4aCoVyvD5fdR6uFMLDAIoQVCIADCczUmkQbyK3BkSvhNrecBYq0dMOVNqIqDmMm1nywNogcHW82tWi0Lk9UoRUZQOmYse9CaJ5RTzq0QSCiERiAgc3NYbgWHGMktWCMC1D4YWFnzhawxfDACYK3Nq2A2QBaNhwN7oJbKnsIHtN+t7PpNlulgBKmuLb1wCGYUA7VZrJaw9erLnrjbmGKBG+rtdL3NBvrmB6AA">
				</section>
				</section>
			<section>
				<section>Mapped Types </section>
				<section>
					<p>Consider this example:</p>
					<aside class="notes"> 
						The in keyword is used there as part of the syntax to iterate over all the items in a union of keys.
					  </aside>
					<pre class="fragment" data-id="code-animation" ><code data-trim data-noescape class="hljs">	<script type="text/template">
						type Properties = "a" | "b"
					</script></code></pre>
					<pre class="fragment" data-id="code-animation" ><code data-trim data-noescape class="hljs">	<script type="text/template">
						type MyMappedType = {
							[P in Properties] : boolean 
						}
					</script></code></pre>
					<p class="fragment"> what would be the type of MyMappedType? </p>
				</section>
				<section>
					<pre data-id="code-animation" ><code data-trim data-noescape class="hljs">	<script type="text/template">
						type MyMappedType = {
							a: boolean;
							b: boolean;
						}						
					</script></code></pre>
				</section>
				<section>
					<p>Reminder: Index signature</p>
				</section>
				<section>
					<pre class="fragment" data-id="code-animation" ><code data-trim data-noescape class="hljs">	<script type="text/template">
						type Fruit = {
							name: string
							color: string
							mass: number
						  }
					</script></code></pre>
					<pre class="fragment" data-id="code-animation" ><code data-trim data-noescape class="hljs">	<script type="text/template">
						type Dict<T> = { [k: string]: T }
					</script></code></pre>
					<p class="fragment">Can I use a specific key?</p>
					<pre class="fragment" data-id="code-animation" ><code data-trim data-noescape class="hljs">	<script type="text/template">
						const fruitCatalog: Dict<Fruit> = {}
							fruitCatalog.apple
					</script></code></pre>
				</section>
				<section>
					<pre class="fragment" data-id="code-animation" ><code data-trim data-noescape class="hljs">	<script type="text/template">
						type Fruit = {
							name: string
							color: string
							mass: number
						  }
					</script></code></pre>
					<pre class="fragment" data-id="code-animation" ><code data-trim data-noescape class="hljs">	<script type="text/template">
						type MyRecord = { [FruitKey in "apple" | "cherry"]: Fruit }
					</script></code></pre>
					<pre class="fragment" data-id="code-animation" ><code data-trim data-noescape class="hljs">	<script type="text/template">
						fruitCatalog.pineapple // Error!
					</script></code></pre>
				</section>
				<section> 
					<p> Mapped allow types to be defined in other types through a much more flexible version of an index signature. We‚Äôll study this type in detail, and demonstrate how it makes language features like indexed access types and conditional types even more powerful!</p>
				</section>
				<section id="fragments">
					<p>Notice:</p>
					<p class="fragment">The in keyword in the mapped type</p>
					<p class="fragment">Index signatures can be on all strings or all numbers, but not some subset of strings or numbers</p>
				</section>
				<section> 
					<p>Lets make our type a bit more generalized</p>
					<pre class="fragment" data-id="code-animation" ><code data-trim data-noescape class="hljs">	<script type="text/template">
						type MyRecord<KeyType extends string, ValueType> = {
							[Key in KeyType]: ValueType
						  }
					</script></code></pre>
					<p class="fragment">Here‚Äôs the built-in TypeScript Record, which matches this pretty much exactly:</p>
					<pre class="fragment" data-id="code-animation" ><code data-trim data-noescape class="hljs">	<script type="text/template">
						type Record<K extends keyof any, T> = {
							[P in K]: T
						  }
					</script></code></pre>
					<p class="fragment"> * keyof any === string | number | symbol</p>
				</section>
				<!-- <section>
					<p>for example: </p>
					<pre class="fragment" data-id="code-animation" ><code data-trim data-noescape class="hljs">	<script type="text/template">
					type FeatureFlags = {
						darkMode: () => void;
						newUserProfile: () => void;
					  };
					   
					  type FeatureOptions = OptionsFlags<FeatureFlags>;
					</script></code></pre>
					<p class="fragment">What is the type of FeatureOptions?</p>
					<div class="fragment">
						<pre class="fragment" data-id="code-animation" ><code data-trim data-noescape class="hljs">	<script type="text/template">

						type FeatureOptions = {
							darkMode: boolean;
							newUserProfile: boolean;
						}
					</script></code></pre>
					</div>
				</section> -->
				<section>
					<h4>Use with indexed access types</h4>
				</section>
				<section>
					<pre  class="fragment" data-id="code-animation" ><code data-trim data-noescape class="hljs">	<script type="text/template">
						type MyMappedType<Type> = {
							[Property in keyof Type]: Type[Property]
						}
						</script></code></pre>
					<pre class="fragment" data-id="code-animation" ><code data-trim data-noescape class="hljs">	<script type="text/template">
							type MyType = MyMappedType<{a:"a", b:"b"}>
						</script></code></pre>
						<p class="fragment"> what would be the value of MyType? </p>
						<p class="fragment">{a:"a", b:"b"}</p>
				</section>
				<section>
					<p>Pick</p>
					<pre  class="fragment" data-id="code-animation" ><code data-trim data-noescape class="hljs">	<script type="text/template">
						type Pick<Type, Keys extends keyof Type> = {
							[Property in Keys]: Type[Property]
						  }
						</script></code></pre>
						<p class="fragment">Or</p>
					<pre  class="fragment" data-id="code-animation" ><code data-trim data-noescape class="hljs">	<script type="text/template">
						type Pick<T, K extends keyof T> = {
							[P in K]: T[P]
						  }
						</script></code></pre>

				</section>
				<section>
					<pre  class="fragment" data-id="code-animation" ><code data-trim data-noescape class="hljs">	<script type="text/template">
						type Person = {
							name: string,
							age: number
						}
						
						type X = Pick<Person, 'name'>
						</script></code></pre>
						<p class="fragment">What is type X ?</p>
					<pre  class="fragment" data-id="code-animation" ><code data-trim data-noescape class="hljs">	<script type="text/template">
						type X = {
							name: string;
						}
						</script></code></pre>
				</section>
				<!-- <section id="fragments">
					<p> lets try to create the Record type</p>
					<pre class="fragment" data-id="code-animation" ><code data-trim data-noescape class="hljs">	<script type="text/template">
						type Record<K extends keyof any, T> = {
							[P in K]: T
						}
					</script></code></pre>
				</section> -->
				<section>
					<h4>Mapped modifiers</h4>
				</section>
				<section id="fragments">
					<p> there are 3 mapped modifiers</p>
					<ul>
						<li class="fragment"> readonly: make the property readonly</li>
						<li class="fragment"> ?: make the property optional </li>
						<li class="fragment"> - : remove optional or readonly </li>
					</ul>
				</section>
				<section>
					<h4>More Examples:</h4>
				</section>
				<section>
					<pre data-id="code-animation" ><code data-trim data-noescape class="hljs">	<script type="text/template">
						type Partial<T> = { [P in keyof T]?: T[P]; };
					</script></code></pre>
				</section>
				<section>
					<pre data-id="code-animation" ><code data-trim data-noescape class="hljs">	<script type="text/template">
						type Readonly<T> = { readonly[P in keyof T]: T[P]; };
					</script></code></pre>
				</section>
				<section>
					<pre data-id="code-animation" ><code data-trim data-noescape class="hljs">	<script type="text/template">
						type NotPartial<T> = { [P in keyof T]-?: T[P]; };
					</script></code></pre>
				</section>
				<section>
					<pre data-id="code-animation" ><code data-trim data-noescape class="hljs">	<script type="text/template">
						type NotReadonly<T> = { -readonly[P in keyof T]: T[P]; };
					</script></code></pre>
				</section>
				<!-- <section>
				 <p> Assignment: </p>	
				 <p> 1. Create a generic type that receives a type and returns the same type but with all its keys as optional (Partial) </p>	
				 <p> 2. Create a generic type that receives a type and returns the same type but with all its keys as readonly (Readonly) </p>	
				</section>
				<section>
					<p> 3. Create a generic type that receives a type and returns the same type but with all its keys as nullable </p>	
					<p> 4. Create a generic type gives the ability to create a new type by picking properties from the already existing model (Pick) </p>
				</section>
				<section>
					Bonus: Create a generic type that receives a type and returns the same type but with all its keys as readonly (nested types too) 
				</section>
				<section>
					<p>Answer 1:</p>
					<pre class="fragment" data-id="code-animation" ><code data-trim data-noescape class="hljs">	<script type="text/template">
						type MyMappedType<T> = {
							[P in keyof T]?: T[P]
						}
					</script></code></pre>
				</section>
				<section>
					<p>Answer 2:</p>
					<pre class="fragment" data-id="code-animation" ><code  data-trim data-noescape class="hljs">	<script type="text/template">
						type MyMappedType<T> = {
							readonly[P in keyof T]: T[P]
						}
					</script></code></pre>
				</section>
				<section>
					<p>Answer 3:</p>
					<pre class="fragment" data-id="code-animation" ><code data-trim data-noescape class="hljs">	<script type="text/template">
						type MyMappedType<T> = {
							[P in keyof T]: T[P] | null
						}
					</script></code></pre>
				</section>
				<section>
					<p>Answer 4:</p>
					<pre class="fragment" data-id="code-animation" ><code data-trim data-noescape class="hljs">	<script type="text/template">
						type Pick<T, K extends keyof T> = {
							[P in K]: T[P];
						};
					</script></code></pre>
				</section>
				<section>
					<p>Bonus:</p>
					<pre class="fragment" data-id="code-animation" ><code data-trim data-noescape class="hljs">	<script type="text/template">
						type DeepReadonly<T> = {
							readonly [P in keyof T]: DeepReadonly<T[P]>;
						};
					</script></code></pre>
				</section> -->
				<section>
					<h4>Prettify</h4>
				</section>
				<section data-background-iframe="https://www.typescriptlang.org/play?#code/JYOwLgpgTgZghgYwgAgEJwM4QCoAtQDmyA3gFDIXIhwC2EAXMhmFIQDTmXAAmjzrIAqQC+pUqEixEKAMIB7OQBs8hZBAAekENwxpMOfILKVkCBYsYAjcxDggOo8eGjwkyeUpWCAqgAducJBqmhDauh7KhgTGlDRy3MAwwBDcAKK+cgi4jCAArjSW0A5iYACevigAgsgAvO7mXgR+AUEAZCTCANxiZiDMpg1RjAAK0GBgiaUAPBGNzYEQAHy1JGKOZRXIo1Djk1PYy3UxFADaw8igyADWEKVyMMjYyAC6jNhnzyLI7cTCQA">
				</section>
				<section>
					<h4>Exercise</h4>
				</section>
				<section data-background-iframe="https://www.typescriptlang.org/play?#code/PTAEGMCcFMEMBdqgAq0vAlrANqAUPAJ4AOSAsoaulrgLyggD8eeIEMCSASnACYD2AO2yECJcoR6wBwwqHpMWbKHEQoM4ANZjSoCsg2b5DYM1ZgAwhzWxQAc2iDokDaCK74ACwSgY4aBgAbtAAzqAAKqCwgry+0PAArpCCYV5IIbAAtkjuSABGCfCgAO4YXlHYuGVhmtCEYbBhggmVsHnY0DoSAHIt2G0dxormoABCQgkhAFygVqpItg5OLuBu4m7eRX4BwWGR0bEwicmpnulZOesFRaXlOFXwNXUNYfzEmEI4oAAUTiGIsVyqX4-AAlPhcqAACLQaDEKiYL4KUx4IA">
				</section>
				<section>
					<h4>Solutions</h4>
				</section>
				<section data-background-iframe="https://www.typescriptlang.org/play?#code/PTAEGMCcFMEMBdqgAq0vAlrANqAUPAJ4AOSAsoaultgDwAqAfKALygDeoA2sqBgHagA1tEIB7AGah6AXQD8ALmk8ZAblABfVXjwgIMBEgBKcACZj+2QgRLlCJ2OcuEGzNpwNOrPPoJHipWSV6FXUtHT0oOEQUDHAhG1JQCmQ4oQYAGlAAaVBoAA9EflMAZ2FRSWk3Dh8BHJlg0PDdMABhAxjYUABzaH5oSDjQIiT4AAsEUBhwaAwAN2gy+lBYYqnoeABXSH4y8aQS2ABbJBGkACNN+FAAdwxxlexce7L-Mtgy-k2n2HPsaESdgAct9sL9-q5WDVeHV-JUgspkDIAD6gL5PTTaFqgABCFk2JSU7WiSC6vX6g3Aw1swwm12mswWSxWaxgWx2ezGB2Opxpl2udweOGe8FeoneZTExEwFhwoAAFP0SohTNTSHsxGIAJT4M6gAAi0GgxComBwkLYywKRVKoDE5wAVtBwNc5NDfOUAtJ5EpDcbTTQGCpGKoNKBgtogA">
				</section>
			</section>
			<section id="fragments">
			<section>

				<p> Template Literal Types </p>	
				<aside class="notes"> 
					Template literal types build on string literal types, and have the ability to expand into many strings via unions.
					
					They have the same syntax as template literal strings in JavaScript, but are used in type positions. 
					When used with concrete literal types, a template literal produces a new string literal type by concatenating the contents.
				</aside>
				<pre class="fragment" data-id="code-animation" ><code data-trim data-noescape class="hljs">	<script type="text/template">
					type World = "world";
					
					type Greeting = `hello ${World}`;
				</script></code></pre>
				<p class="fragment"> type Greeting = "hello world" </p>
				<aside class="notes"> 
					With Template literal types toy can dynamically create new static types!
				  </aside>
			</section>
			<section>
				<p>I can also: </p>
				<pre class="fragment" data-id="code-animation" ><code data-trim data-noescape class="hljs">	<script type="text/template">
					type Greeting = `hello ${string}`;
				</script></code></pre>
			</section>
			<section>
				<p> Another  example: </p>
				<pre class="fragment" data-id="code-animation" ><code data-trim data-noescape class="hljs">	<script type="text/template">
					type CSSValue = number | `${number}px` | ${number}em | ${number}rem
				</script></code></pre>
			</section>
			<section>
				<h4> Template Literal Types with mapped types</h4>
			</section>
			<section>
				<pre  data-id="code-animation" ><code data-trim data-noescape class="hljs">	<script type="text/template">
					type MappedTypeToString<T> = {
						[K in keyof T as `string-${string & K}`]: string
					}
				</script></code></pre>
			</section>
			<section data-background-iframe="https://www.typescriptlang.org/play?#code/C4TwDgpgBAYhCGwCuAnCBnKBeKBvKAUAJABmCyaAggFxQAUAlFgHwBuA9gJYAmxZiqCACFajFhx59yggMKimbLrwC+BAqEixpadABV2cAWhgAbeAHN0AHl3NseYgG0A0lE4A7KOmAoP5qABkUADWECDsJFC6UPCYAAYAJLjOyqYWcQC6tABG7OwmCO4Equrg0IYUEGmW9hWCegbaVWaWVnU6zEA">
			</section>
				
			<section>
				<p>When a union is used in the interpolated position, the type is the set of every possible string literal that could be represented by each union member:</p>
				<pre class="fragment" data-id="code-animation" ><code data-trim data-noescape class="hljs">	<script type="text/template">
					type EmailLocaleIDs = "welcome_email" | "email_heading";
					type FooterLocaleIDs = "footer_title" | "footer_sendoff";
					 
					type AllLocaleIDs = `${EmailLocaleIDs | FooterLocaleIDs}_id`;
				</script></code></pre>
				<p class="fragment"> type AllLocaleIDs = "welcome_email_id" | "email_heading_id" | "footer_title_id" | "footer_sendoff_id" </p>
			</section>
			<section>
				<p>For each interpolated position in the template literal, the unions are cross multiplied:</p>
				<pre class="fragment" data-id="code-animation" ><code data-trim data-noescape class="hljs">	<script type="text/template">
					type AllLocaleIDs = `${EmailLocaleIDs | FooterLocaleIDs}_id`;
					type Lang = "en" | "ja" | "pt";
					 
					type LocaleMessageIDs = `${Lang}_${AllLocaleIDs}`;
				</script></code></pre>
				<p class="fragment">
					type LocaleMessageIDs = "en_welcome_email_id" | "en_email_heading_id" | "en_footer_title_id" | "en_footer_sendoff_id" | "ja_welcome_email_id" | "ja_email_heading_id" | "ja_footer_title_id" | "ja_footer_sendoff_id" | "pt_welcome_email_id" | "pt_email_heading_id" | "pt_footer_title_id" | "pt_footer_sendoff_id"
				</p>
			</section>
			<section data-background-iframe="https://www.typescriptlang.org/play?ssl=6&ssc=6&pln=6&pc=14#code/C4TwDgpgBAwg9gGzgJwM5QLxSgIgEYICuEOUAPrgObIQQB2pFuNAJqQFCiRQDqAFhBqZceAIYBjANbU4hOm3K5gEAB7Ac7TuGgBBBAgAyccaIQQAkgBF0WAAYASAN7wkaAL4B9J-0EQ3tgG5NLmgAWRAXFBsoRwBtAAUoAEs6KD1DY1MLawBdAC4oVGBkFMo3IA">
			</section>
			</section>
			<section data-background-iframe="https://github.com/mike-north/types">
			</section>
			<section data-background-iframe="https://www.learningtypescript.com/articles/extreme-explorations-of-typescripts-type-system">
			</section>
			<section>
				<h4>Typescript Tips and Tricks</h4>
			</section>
			<section>
				<h4>Mutable vs. Immutable</h4>
				<ul class="fragment">
					<li>Predictability</li>
					<li>Performance</li>
					<li>Mutation tracking</li>
				</ul>
			</section>
			<section>
				<pre><code class="language-typescript" data-noescape data-trim>
					const user = {
						firstnname: 'Hatul',
						lastname: 'Hatuli'
					}
					function checkValidityAndFireRockets(u: typeof user){
						if(u.firstnname && u.lastname){
							u.firstnname = u.firstnname.toLowerCase();
							return user;
						}
					
						return null;
					}
					const validatedUser = checkValidityAndFireRockets(user);
					console.log(user === validatedUser);
					console.log(user.firstnname === 'Hatuli');
				</code></pre>
			</section>
			<section>
				<img src="../../assets/i-see.jpeg" />
			</section>
			<section>
				<h2>Deep readonly! üôå</h2>
				<pre><code class="language-typescript" data-noescape data-trim>
					type DeepReadonly<T> = {
						readonly [P in keyof T]: DeepReadonly<T[P]>;
					};
				</code></pre>
			</section>
			<section>
				<pre><code class="language-typescript" data-noescape data-trim>
					const user = {
						firstnname: 'Hatul',
						lastname: 'Hatuli'
					}
					type ReadonlyUser = DeepReadonly&lt;typeof user>;
					function checkValidityAndFireRockets(u: ReadonlyUser) {
						if (u.firstnname && u.lastname) {
							u.firstnname = u.firstnname.toLowerCase(); // Cannot assign to 'firstnname' because it is a read-only property.
							return user;
						}
						return null;
					}
					const validatedUser = checkValidityAndFireRockets(user);
					console.log(user === validatedUser);
					console.log(user.firstnname === 'Hatuli');
				</code></pre>
			</section>
			<section>
				<h3>Exceptionless Programming</h3>
				<a href="https://medium.com/att-israel/exceptionless-programming-80b3e06b1f4e">https://medium.com/att-israel/exceptionless-programming-80b3e06b1f4e</a>
			</section>
			<section>
				<h2>Using Unions</h2>
				<pre><code class="language-typescript" data-noescape data-trim>
					class Actor{
						async onMessageReceived(message: Message){
						  const [error, status] = await handleMessage(mesaage);
						  if(error){
							// do something with the error
							return;
						  }
						  
						  // do something with the result
						}
					}
					
					async function handleMessage(message: Message): Promise<[Error | null, Status | null]> {
					  switch(message.name){
						case 'create-user':
						  // do some work 
						  return [null, Status.Handled];
						default:
						  return [new Error('unkown message name'), null];
					  }
					}
				</code></pre>
			</section>
			<section>
				<h2>Using Narrowing</h2>
				<p>Using union to differentiate between error and payload</p>
			</section>
			<section  id="fragments" data-background-color="white" data-background-iframe="https://www.typescriptlang.org/play?#code/KYDwDg9gTgLgBASwHY2FAZgQwMbDgUSimgCVgBnSJcvAbwCg5FzDioAuOGKAV2AG5GcNG06to9AL716oSLEQo0WXHABqmADYIAJmUoRqwADwAVAHxwGTBCyLROWTTUFMwmAJ6aImHZ1OC0jKy4NDwMB5geOJQAPJQ+lQ0ZpYAvOpauomGyRZwAD4E9gkUSQIy6DxI2DAIhnAA5sAwACKYMJgAFACUYsXx2UbG5NzIDZbWXFAeVkJM2DnwUKU5eOlNre2YAGLEALYAymgAbmg9rkxwyzA8UEizl5e2MY5aNAA0c5fuXj5+VysjF9pExJHBsO1sAALOCdETQboPS4LajwNbCYpwTDkIpsC5Ma63e6TR7PYqcbh8T6PJjwjjCYFCaRBeiVaq1eobNodXYQQ4nM6IyaEu5wADkOi2YsCwTZNTq9z2mGQPSRKJGAIMRjg62a3K63QuCHQsOWWpoADoyWwhV91RBNMALd4Gp0zWULXTDUzhM46Hacg6nS63YDLT9vL5vaCZEEAPRxuAAWhTqbT6Yzmaz2Zzubz+dTFSq8s5eq2ACYen02AMwyYRlAxhMhNwZiTwYtNWUdY0yzz9kcoKcoOcviL7thlu1gDFa+bgKH59G4GCITBobCvUj5p30XSsTiYviATdRZPgNPZyV58NRkhxnDukypEX2QrwVPUFfBrke1UANZIBAADuSDmHC-TXmU1bQAUcCmL0uLQHOZQpEixqbpBP54MgIyYNUwAQCaMS2o847bk8diiFMVJfLS5IYjWUGrIyMZCOR7bWg4cBOB8XwRn8nB0ihLExpIQA" data-background-interactive>
			</section>
			</div>
		</div>

		<script src="../../dist/reveal.js"></script>
		<script src="../../plugin/notes/notes.js"></script>
		<script src="../../plugin/markdown/markdown.js"></script>
		<script src="../../plugin/highlight/highlight.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
			});
		</script>
	</body>
</html>



<!-- <pre class="fragment" data-id="code-animation" ><code class="hljs" data-trim data-noescape>>	<script type="text/template">
				
</script></code></pre> -->