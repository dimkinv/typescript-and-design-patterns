<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="../../dist/reset.css">
		<link rel="stylesheet" href="../../dist/reveal.css">
		<link rel="stylesheet" href="../../dist/theme/black.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="../../plugin/highlight/monokai.css">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
                <section>
                    <section>

                        <aside class="notes"> 
                            <p>
                                In software engineering, a software design pattern is a general, reusable solution to a commonly occurring problem within a given context in software design.
                            </p>
                            <p>
                                the book is divided into two parts, with the first two chapters exploring the capabilities and pitfalls of object-oriented programming, and the remaining chapters describing 23 classic software design patterns.
                            </p>
                        </aside>
                        <h4>Design Patterns</h4>
                    </section>
                    <section  data-background-color="white" data-background-iframe="https://refactoring.guru/design-patterns" data-background-interactive>
                    </section>
                </section>
                <section>
                    <section>
                        <h4>Behavioural</h4>
                    </section>
                        <section> 
                           <h4> Strategy </h4> 
                        </section> 
                        <section>
                            <p > Strategy is a behavioral design pattern that
                                 lets you define a family of algorithms, put each of them into a separate class, and make their objects interchangeable. </p>
                            <aside class="notes"> 
                                The strategy pattern brings the ability to bring the most appropriate algorithm, from a group of simmilar algorithms, at run time.
                              </aside>
                        </section>
                        <section>
                            <img src="../../assets/strategy-example.png" alt="">
                            <aside class="notes"> 
                                The Strategy pattern suggests that you take a class that does something specific in a lot of different ways and extract all of these algorithms into separate classes called strategies.							</aside>
                        </section>
                        <section>
                            <h4>Demo</h4>
                        </section>
                        <section>
                            <p>Pros and Cons</p>
                        </section>
                        <section id="fragments">
                           <p> Pros </p>
                           <ul>
                               <li class="fragment"><p> You can swap algorithms used inside an object at runtime. </p></li>
                               <li class="fragment"><p>You can isolate the implementation details of an algorithm from the code that uses it.</p></li>
                               <li class="fragment"><p>You can replace inheritance with composition.</p></li>
                               <li class="fragment"><p>Open/Closed Principle. You can introduce new strategies without having to change the context.</p></li>
                           </ul>
                        </section>
                        <section id="fragments">
                           <p> Cons </p>
                           <ul>
                               <li class="fragment"><p> If you only have a couple of algorithms and they rarely change, there’s no real reason to overcomplicate the program with new classes and interfaces that come along with the pattern. </p></li>
                               <li class="fragment"><p> Clients must be aware of the differences between strategies to be able to select a proper one.</p></li>
                           </ul>
                        </section>
                        <section>
                            <h3>
                                Exercise
                            </h3>
                            <p>In the Exercises project, look at the strategy/ChatClient class. This class uses an encryption algorithm to encrypt a message before sending it out.  What are the problems in this implementation? Refactor the code using the strategy pattern. What are the benefits of the new implementation? </p>
                        </section>
						<section> 
                          <h4> State  </h4>  
                        </section>
                        <section>
                            <p > State is a behavioral design pattern that lets an object alter its behavior when its internal state changes. It appears as if the object changed its class. </p>
                        </section>
                        <section>
                            <img src="../../assets/state-example.png" alt="">
                        </section>
                        <section>
                            <h4>Demo</h4>
                        </section>
                        <section>
                            <p> State vs Strategy</p>
                                <aside class="notes"> 
                                This structure may look similar to the Strategy pattern, but there’s one key difference. In the State pattern, the particular states may be aware of each other and initiate transitions from one state to another, whereas strategies almost never know about each other.
                              </aside>
                        </section>
                        <section>
                            <p>Pros and Cons</p>
                        </section>
                        <section id="fragments">
                           <p> Pros </p>
                           <ul>
                               <li class="fragment"><p> Single Responsibility Principle. Organize the code related to particular states into separate classes. </p></li>
                               <li class="fragment"><p> Open/Closed Principle. Introduce new states without changing existing state classes or the context.</p></li>
                               <li class="fragment"><p>Simplify the code of the context by eliminating bulky state machine conditionals.</p></li>
                           </ul>
                        </section>
                        <section id="fragments">
                           <p> Cons </p>
                           <ul>
                               <li class="fragment"><p> Applying the pattern can be overkill if a state machine has only a few states or rarely changes. </p></li>
                           </ul>
                        </section>
                        <section>
                            <h3>
                                Exercise
                            </h3>
                            <p>
                                In the Exercises project, look at the code in the state/DirectionService class. This is the class that powers our mapping app for triathletes. 
                                It provides three methods for calculating the estimated time of arrival (ETA), the direction between two points 
                                and last method for switching to the next part of the race (e.g. swmming to bicycling) name this method switchPoint.
                                you need to implement the last method in this task as well. it is not implemented.
                                
                                Identify the problems in this implementation. 
                                Then, refactor the code to use the state pattern. 
                            </p>
                        </section>
						<section> 
                            <h4> Observer  </h4>
                        </section>
                        <section>
                            <p>Observer is a behavioral design pattern that lets you define a subscription mechanism to notify multiple objects about any events that happen to the object they’re observing.</p>
                        </section>
                        <section>
                            <img src="../../assets/observer-example.png" alt="">
                        </section>
                        <section>
                            <h4>Demo</h4>
                        </section>
                        <section id="fragments">
                            <h4>pros</h4>
                            <p class="fragment"> Open/Closed Principle. You can introduce new subscriber classes without having to change the publisher’s code (and vice versa if there’s a publisher interface). </p>
                            <p class="fragment"> You can establish relations between objects at runtime.</p>
                        </section>
                        <section id="fragments">
                            <h4>cons</h4>
                            <p class="fragment">  Subscribers are notified in random order. </p>
                        </section>
                        <section>
                            <h3>
                                Exercise
                            </h3>
                            <p>
                                We’re building an application for watching the price of various stocks. There are two places in our application where we need to display the stocks:  -StatusBar: shows the popular stocks  -StockListView: shows the complete list of stocks When the price of a stock changes, the corresponding views (StatusBar and/or StockListView) need to be refreshed to reflect the latest price.  Our application currently does not have the ability to communicate the change in stock prices to the corresponding views.  Use the observer pattern to solve this problem. 
                            </p>
                        </section>
                        <section>
                            <h4>Chain of Responsibility </h4>
                        </section>
                        <section>
                            <p>Chain of Responsibility is a behavioral design pattern that lets you pass requests along a chain of handlers. Upon receiving a request, each handler decides either to process the request or to pass it to the next handler in the chain.</p>
                        </section>
                        <section>
                            <img src="../../assets/chain-of-responsibility.png" alt="">
                        </section>
                        <section>
                            <h4>Demo</h4>
                        </section>
                        <section id="fragments">
                            <h4>pros</h4>
                            <p class="fragment">  You can control the order of request handling. </p>
                            <p class="fragment"> Single Responsibility Principle. You can decouple classes that invoke operations from classes that perform operations.</p>
                            <p class="fragment"> Open/Closed Principle. You can introduce new handlers into the app without breaking the existing client code.</p>
                        </section>
                        <section id="fragments">
                            <h4>cons</h4>
                            <p class="fragment"> Some requests may end up unhandled. </p>
                        </section>
                    
                    </section>
				<section>
					<section> <h4> Structural </h4></section>
                    <section> 
                       <p> Adapter  </p>
                    </section>
                    <section>
                        <p>Adapter is a structural design pattern that allows objects with incompatible interfaces to collaborate</p>
                    </section>
                    <section>
                        <img src="../../assets/adapter-example.png" alt="">
                    </section>
                    <section>
                        <p>Demo</p>
                    </section>
                    <section>
                        <p>Pros and Cons</p>
                    </section>
                    <section id="fragments">
                        <p> Pros </p>
                        <ul>
                            <li class="fragment"><p>  Single Responsibility Principle. You can separate the interface or data conversion code from the primary business logic of the program. </p></li>
                            <li class="fragment"><p>  Open/Closed Principle. You can introduce new types of adapters into the program without breaking the existing client code, as long as they work with the adapters through the client interface.</p></li>
                        </ul>
                     </section>
                     <section id="fragments">
                        <p> Cons </p>
                        <ul>
                            <li class="fragment"><p> The overall complexity of the code increases because you need to introduce a set of new interfaces and classes. Sometimes it’s simpler just to change the service class so that it matches the rest of your code. </p></li>
                        </ul>
                     </section>
				</section>
                <section>
                    <h4>Creational</h4>
                </section>
                <section data-transition="slide-in none">
                    <h4>Factory Pattern</h4>
                    <img src="../../assets/dirty-factory.jpeg" />
                    
                </section>
                <section data-transition="none">
                    <h4>factory pattern</h4>
                    <img src="../../assets/clean-factory.jpeg" />
                </section>
                <section>
                    <h4>What it is good for?</h4>
                    <ul>
                        <li class="fragment">Creating different objects instead of classes based on configurations</li>
                        <li class="fragment">Addressing interface instead of concrete class</li>
                        <li class="fragment">Hiding initialization which cannot go into constructor</li>
                    </ul>
                </section>
                <section>
                    <h4>Simplest example</h4>
                    <pre><code  data-trim data-noescape class="language-typescript">function getHttpClient(){
    const httpClient = new HttpClient()
    return httpClient;
}

class HttpClient{

}
                    </code></pre>
                </section>
                <section>
                    <h4>Configuraiton Based example</h4>
                    <pre><code class="language-typescript" data-trim data-noescape >
                        enum TransportClientType { HTTP, TCP }
                        function getTransportClient(transportClientType: TransportClientType): TransportClient {
                            switch (transportClientType){
                                case TransportClientType.HTTP: return new HttpTransportClient();
                                case TransportClientType.TCP: return new TcpTransportClient();
                            }
                        }
                        
                        interface TransportClient { send(): void }
                        class HttpTransportClient implements TransportClient { send() { } }
                        class TcpTransportClient implements TransportClient { send() { } }
                    </code></pre>
                </section>
                <section>
                    <h4>together with strategy pattern</h4>
                    <pre><code class="language-typescript" data-trim data-noescape >
                        interface TransportClient { send(): void }
                        class HttpTransportClient implements TransportClient { send() { } }
                        class TcpTransportClient implements TransportClient { send() { } }

                        enum TransportClientType { HTTP, TCP }
                        const transports = new Map<TransportClientType, Constructor<TransportClient>>();
                        transports.set(TransportClientType.HTTP, HttpTransportClient);
                        transports.set(TransportClientType.TCP, TcpTransportClient);

                        function getTransportClient(transportClientType: TransportClientType): TransportClient | null {
                            const TransportConstructor = transports.get(transportClientType);
                            if(!TransportConstructor) {
                                return null
                            }
                            
                            const transport = new TransportConstructor();
                            // add more configurations here
                            return transport;
                        }
                    </code></pre>
                </section>
                <section>
                    <h4>together with depedency injection (angular/nestjs)</h4>
                    <img src="../../assets/factory-with-di.png"/>
                </section>
                <section>
                    <h4>Notable factory pattern implementations</h4>
                    <ul>
                        <li><a href="https://expressjs.com/en/4x/api.html#router">Express router</a></li>
                        <li><a href="https://github.com/winstonjs/winston">Winston logger</a></li>
                    </ul>
                </section>
                <section>
                    <h4>DI / IoC</h4>
                    <p class="fragment">IoC - Inversion of Control, the ability to get dependencies from ourside source</p>
                    <p class="fragment">DI - Dependency Injection - specific implmentation of IoC</p>
                </section>
                <section>
                    <h4>Inversion of control</h4>
                    <p>
                        The art of not taking responsibility 😈
                    </p>
                    <p>Let someone else to give you dependencies</p>
                </section>
                <section>
                    <h4>Dependency Injection</h4>
                    <p>Specific implmenetation of IoC</p>
                </section>
                <section>
                    <h4>The Problem:</h4>
                    <pre><code class="language-typescript">
    export class UserService{
        private userPersistenceService: UserPersistenceService;
        constructor(){
            this.userPersistenceService = new UserPersistenceService();
        }
    
        saveUser(user: User){
            this.userPersistenceService.saveUser(user);
        }
    }                        
    const userService = new UserService();
    userService.saveUser({});
                        </code></pre>
                </section>
                <section>
                    <h4>The naive solution</h4>
                    <pre><code class="language-typescript">
    export class UserService{
        constructor(private userPersistenceService: UserPersistenceService){}
    
        saveUser(user: User){
            this.userPersistenceService.saveUser(user);
        }
    }
    const userService = new UserService(new UserPersistenceService());
    userService.saveUser({});
                        </code></pre>
                </section>
                <section>
                    <h4>Better solution</h4>
                    <pre><code class="language-typescript">
    export class UserService{
        constructor(private userPersistenceService: UserPersistenceService){}
    
        saveUser(user: User){
            this.userPersistenceService.saveUser(user);
        }
    }
    const userPersistenceService = injector.get(UserPersistenceService);
    const userService = new UserService(userPersistenceService);
    userService.saveUser({});
                        </code></pre>
                </section>
                <section>
                    <h4>best solution</h4>
                    <pre><code class="language-typescript">@injectable()
    export class UserPersistenceService(){
    }
    
    @injectable()
    export class UserService {
        constructor(@inject() private userPersistenceService: UserPersistenceService) { }
    
        saveUser(user: User) {
            this.userPersistenceService.saveUser(user);
        }
    }
    const userService = injector.get(UserService);
    userService.saveUser({});
                        </code></pre>
                </section>
                <section>
                    <h4>Frameworks and libraries</h4>
                    <ul style="list-style: none;">
                        <li>Angular - client framework with DI</li>
                        <li>Nest.js - backend framwork with DI</li>
                        <li><a href="https://inversify.io/">Inversify</a> - IoC implementation for typescript</li>
                    </ul>
                </section>
                <section>
                    <h2>Decorators - Again</h2>
                    <p>
                        A kind reminder...
                    </p>
                </section>
                <section>
                    <h1>Exercise</h1>
                </section>
                <section>
                    <h4>Feedback pattern</h4>
                    <a href="https://att.surveymonkey.com/r/AdvTSandDP0422">https://bit.ly/3rq6Su3</a>
                </section>
			</div>
		</div>

		<script src="../../dist/reveal.js"></script>
		<script src="../../plugin/notes/notes.js"></script>
		<script src="../../plugin/markdown/markdown.js"></script>
		<script src="../../plugin/highlight/highlight.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
			});
		</script>
	</body>
</html>
